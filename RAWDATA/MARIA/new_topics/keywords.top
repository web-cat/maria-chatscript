topic: ~keywords keep repeat [keyword "reserved word"]

u: (abstract)
The <code>abstract</code> keyword is used make abstract classes and methods. You should put the word in the class or method declaration. Abstract classes are just classes that contain abstract methods. Abstract methods are methods with no body. They should only be a method header with a semicolon after.

	a: (tell me more)
	^reuse(~java.ABSTRACT_CLASS)

u: (assert)
You'll probably never use this word.
<br/>But, if you're curious, it is used to make assertions (like the ones you make in test files) in less refined way. You use it like this:
<pre>
assert /*condition*/ : /*message to print if condition is false*/ </pre>
Java should also generate a runtime error if the condition is false, but these runtime errors are sometimes turned off in some compliers.
^refine() a: () ^reuse(~feedback.FEEDBACK)

u: (boolean)
The <code>boolean</code> keyword is used to create boolean variables. Pretty simple.
^refine() a: () ^reuse(~feedback.FEEDBACK)

u: (break)
The <code>break</code> keyword is used to in a few places. In a <code>switch</code> statement, they are used to separate different cases if you don't want code to fall through. It is also used in loops to break out of the loop. This allows you to end a loop before the loop condition is false. For example, in the following loop, the loop will end when <code>i</code>=2, instead of when <code>i</code>=5, as you would expect.
[<pre>
for(int i = 0; i < 5; i++)
{
   if (i == 2)
   {
      break; 
   }
}</pre>]
It is generally bad practice to use break statements in loops.
<br/>...

	a: (tell me more)
	Interestingly, you can name loops in Java and you can use <code>break</code> statements to break out of specific loops. This makes <code>break</code> statements almost able to do everything <code>goto</code> statements are able to do. Here's an example:
	<pre>
outer: //name for outer loop
for(int i = 0; i < 5; i++)
{
   inner:
   for(int j = 0; j < 5; j++)
   {
	  System.out.println("foo");
      break outer;
   }
}</pre>
	Here, "foo" is only printed once, because we break out of the outer loop after we first get into the inner loop. If we omitted the <code>outer</code> from the <code>break</code> statement, then, "foo" would be printed 5 times because we would only break out of the inner loop.
	^refine() b: () ^reuse(~feedback.FEEDBACK)
	
u: (byte)
The <code>byte</code> keyword is just used to create variables of type <code>byte</code>. 
^refine() a: () ^reuse(~feedback.FEEDBACK)

u: (case)
The <code>case</code> keyword is used inside of switch statements to specify all of the different values that the variable can be and the actions that should be taken for each of the values. 
^refine() a: () ^reuse(~feedback.FEEDBACK)

u: (catch)
The <code>catch</code> keyword is used to used in try-catch statements (obviously to make the catch part of the try-catch statement.
^refine() a: () ^reuse(~feedback.FEEDBACK)

u: (const)
The <code>const</code> keyword is not currently used in Java. It may be a relic of Java's C origins. In C, <code>const</code> is used like <code>final</code> is used in Java. 
^refine() a: () ^reuse(~feedback.FEEDBACK)

u: (class)
The <code>class</code> keyword is used to define classes. 
^refine() a: () ^reuse(~feedback.FEEDBACK)

u: (continue)
The <code>continue</code> keyword is used in loops. It is similar to <code>break</code> but, when it is used, the loop does not exit. Instead, the loop's current iteration will end and it will move on to the next iteration. For example, in the following code, only the numbers 1 and 3 will be printed because the <code>continue</code> makes the loop miss the print statement that would have printed 2:
<pre>
for (int i = 1; i <= 3; i++)
{
   if (i == 2)
   {
      continue;
   }
   System.out.println(i);
}</pre>
<pre>
OUTPUT:
1
3</pre>
^refine() a: () ^reuse(~feedback.FEEDBACK)

u: (default)
The <code>default</code> keyword is used in a few interesting places. 
^refine() a: () ^reuse(~feedback.FEEDBACK)

u: (finally)
The keyword <code>finally<code> is used after a try-catch statement. You should put a block of code after the <code>finally</code> keyword. This code will always be run, regardless of whether or not an exception was caught.
<br/>The key takeaway: Code in a <code>finally</code> block is ALWAYS executed.
^refine() a: () ^reuse(~feedback.FEEDBACK)

u: (final)
Basically, you use <code>final</code> to create constants like this:
<pre>
final int one = 1;
</pre>
<br/>Now, <code>one</code>'s value cannot be changed from 1. 
<br/>...

	a: (tell me more)
	You can use <code>final</code> in these many ways:
	<p>1. To create primitives with constant values.
	<br/>As I said above, you can use <code>final</code> in front of a primitive declaration to create a variable whose value cannot be changed.
	<p>2. To create a constant reference to an Object.
	<br/>In the case of Objects (<code>final Object obj = ...</code>), the behavior is a little more complicated. The use of <code>final</code> in this case makes it so that <code>obj</code> can never be made to reference another Object. This means you can call methods on <code>obj</code> and "alter" the Object, but you cannot say <code>obj = /*some new, different Object*/</code>. If you understand pointers, this makes sense. The real "value" of <code>obj</code> is just a pointer. So, this pointer is never allowed to change, but attributes of the Object being pointed to can be changed.
	<p>3. To make methods that cannot be overridden in subclasses.
	<br/>If you put <code>final</code> in a method header (<code>public final void ...</code>), then, this method cannot be overridden in any subclass. There can never be another <code>method()</code> method that does anything else.
	<p>4. To make classes that cannot be subclassed.
	<br/>If you use <code>final</code> in a class declaration (<code>public final class ...</code>), then that class can never have any subclasses. It can never be the parent to another class.
	^refine() b: () ^reuse(~feedback.FEEDBACK)