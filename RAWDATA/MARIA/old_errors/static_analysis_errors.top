# =============================================================================
# This topic contains information on static analysis errors.
# =============================================================================
topic: ~static_analysis_errors keep repeat (static analysis errors java messages)

# Naming Checkstyle

u: (ConstantName) Validates identifiers for constants \(static, final fields \).

u: (constant name) Validates identifiers for constants \(static, final fields \).

u: (LocalVariableName) Checks that local, non-final variable names conform to a format specified by the format property.

u: (local variable name) Checks that local, non-final variable names conform to a format specified by the format property.

u: (LocalFinalVariableName) Validates identifiers for local, final variables, including catch parameters and resources in try statements.

u: (local final variable name) Validates identifiers for local, final variables, including catch parameters and resources in try statements.

u: (MemberName) Validates identifiers for non-static fields.

u: (member name) Validates identifiers for non-static fields.

u: (MethodName) Validates identifiers for methods.

u: (method name) Validates identifiers for methods.

u: (ParameterName) Checks that method and catch parameter names conform to a format specified by the format property. By using accessModifiers property it is possible to specify different formats for methods at different visibility levels.

u: (parameter name) Checks that method and catch parameter names conform to a format specified by the format property. By using accessModifiers property it is possible to specify different formats for methods at different visibility levels.

u: (StaticVariableName) Validates identifiers for static, non-final fields.

u: (static variable name) Validates identifiers for static, non-final fields.

u: (MethodTypeParameterName) Validates identifiers for method type parameters.

u: (method type parameter name) Validates identifiers for method type parameters.

u: (TypeName) Validates identifiers for classes, interfaces, enums, and annotations.

u: (type name) Validates identifiers for classes, interfaces, enums, and annotations.

u: (ClassTypeParameterName) Validates identifiers for class type parameters.

u: (class type parameter name) Validates identifiers for class type parameters.

u: (PackageName) Validates identifiers for packages.

u: (package name) Validates identifiers for packages.

# Naming PMD

u: (ShortVariable) Detects when a field, local, or parameter has a very short name.
<div class="source"><pre>

public class Something \{
  private int q = 15; // VIOLATION - Field
  public static void main \( String as \[\] \) \{  // VIOLATION - Formal
    int r = 20 + q; // VIOLATION - Local
    for \(int i = 0; i &lt; 10; i++ \) \{ // Not a Violation \(inside FOR \)
      r += q;
    \}
  \}
\}


            </pre></div>

u: (short variable) Detects when a field, local, or parameter has a very short name.
<div class="source"><pre>

public class Something \{
  private int q = 15; // VIOLATION - Field
  public static void main \( String as \[\] \) \{  // VIOLATION - Formal
    int r = 20 + q; // VIOLATION - Local
    for \(int i = 0; i &lt; 10; i++ \) \{ // Not a Violation \(inside FOR \)
      r += q;
    \}
  \}
\}


            </pre></div>

u: (LongVariable) Detects when a field, formal or local variable is declared with a long name.
<div class="source"><pre>

public class Something \{
  private int q = 15; // VIOLATION - Field
  public static void main \( String as\[\] \) \{  // VIOLATION - Formal
    int r = 20 + q; // VIOLATION - Local
    for \(int i = 0; i &lt; 10; i++ \) \{ // Not a Violation \(inside FOR \)
      r += q;
    \}
  \}
\}


            </pre></div>

u: (long variable) Detects when a field, formal or local variable is declared with a long name.
<div class="source"><pre>

public class Something \{
  private int q = 15; // VIOLATION - Field
  public static void main \( String as\[\] \) \{  // VIOLATION - Formal
    int r = 20 + q; // VIOLATION - Local
    for \(int i = 0; i &lt; 10; i++ \) \{ // Not a Violation \(inside FOR \)
      r += q;
    \}
  \}
\}


            </pre></div>

u: (ShortMethodName) Detects when very short method names are used.

<div class="source"><pre>

public class ShortMethod {
  public void a \( int i \) { // Violation
  \}
\}


            </pre></div>

u: (short method name) Detects when very short method names are used.

<div class="source"><pre>

public class ShortMethod {
  public void a \( int i \) { // Violation
  \}
\}


            </pre></div>

u: (MethodWithSameNameAsEnclosingClass) Non-constructor methods should not have the same name as the enclosing class.
<div class="source"><pre>

public class MyClass \{
 // this is bad because it is a method
 public void MyClass \(\) \{\}
 // this is OK because it is a constructor
 public MyClass \(\) \{\}
\}


            </pre></div>

u: (method with same name as enclosing class) Non-constructor methods should not have the same name as the enclosing class.
<div class="source"><pre>

public class MyClass \{
 // this is bad because it is a method
 public void MyClass \(\) \{\}
 // this is OK because it is a constructor
 public MyClass \(\) \{\}
\}


            </pre></div>

u: (AvoidFieldNameMatchingTypeName) It is somewhat confusing to have a field name matching the declaring class name. This probably means that type and or field names could be more precise.
<div class="source"><pre>

public class Foo extends Bar \{
 // There's probably a better name for foo
 int foo;
\}


            </pre></div>

u: (avoid field name matching type name) It is somewhat confusing to have a field name matching the declaring class name. This probably means that type and or field names could be more precise.
<div class="source"><pre>

public class Foo extends Bar \{
 // There's probably a better name for foo
 int foo;
\}


            </pre></div>


# Formatting Checkstyle

u: (FileTabCharacter) Checks that there are no tab characters \('\t' \) in the source code.

<h4>Rationale:</h4>
<ul>
<li>Developers should not need to configure the tab width of their text editors in order to be able to read source code. </li>
<li>From the Apache jakarta coding standards: In a distributed development environment, when the commit messages get sent to a mailing list, they are almost impossible to read if you use tabs. </li>
</ul>

u: (file tab character) Checks that there are no tab characters \('\t' \) in the source code.

<h4>Rationale:</h4>
<ul>
<li>Developers should not need to configure the tab width of their text editors in order to be able to read source code. </li>
<li>From the Apache jakarta coding standards: In a distributed development environment, when the commit messages get sent to a mailing list, they are almost impossible to read if you use tabs. </li>
</ul>

u: (author comment) Check if there is a \@author tag in the Javadoc. Usually helps to know the author of a program.

u: (LineLength) Checks for long lines.

Rationale: Long lines are hard to read in printouts or if developers have limited screen space for the source code, e.g. if the IDE displays additional information like project tree, class hierarchy, etc.

u: (line length) Checks for long lines.

Rationale: Long lines are hard to read in printouts or if developers have limited screen space for the source code, e.g. if the IDE displays additional information like project tree, class hierarchy, etc.

u: (indentation) Checks correct indentation of Java code.

The idea behind this is that while pretty printers are sometimes convenient for bulk reformats of legacy code, they often either aren't configurable enough or just can't anticipate how format should be done. Sometimes this is personal preference, other times it is practical experience. In any case, this check should just ensure that a minimal set of indentation rules is followed.

u: (EmptyForIteratorPad) Checks the padding of an empty for iterator; that is whether white space is required at an empty for iterator, or such white space is forbidden. No check occurs if there is a line wrap at the iterator, as in

for \(Iterator foo = very.long.line.iterator \(\);
      foo.hasNext \(\);
     \)

u: (empty for iterator pad) Checks the padding of an empty for iterator; that is whether white space is required at an empty for iterator, or such white space is forbidden. No check occurs if there is a line wrap at the iterator, as in

for \(Iterator foo = very.long.line.iterator \(\);
      foo.hasNext \(\);
     \)

u: (NoWhitespaceAfter) Checks that there is no whitespace after a token. More specifically, it checks that it is not followed by whitespace, or \(if linebreaks are allowed \) all characters on the line after are whitespace. To forbid linebreaks after a token, set property allowLineBreaks to false.

The check processes ARRAY_DECLARATOR and INDEX_OP tokens specially from other tokens. Actually it is checked that there is no whitespace before this tokens, not after them. Space after the ANNOTATIONS before ARRAY_DECLARATOR and INDEX_OP will be ignored.

u: (no whitespace after) Checks that there is no whitespace after a token. More specifically, it checks that it is not followed by whitespace, or \(if linebreaks are allowed \) all characters on the line after are whitespace. To forbid linebreaks after a token, set property allowLineBreaks to false.

The check processes ARRAY_DECLARATOR and INDEX_OP tokens specially from other tokens. Actually it is checked that there is no whitespace before this tokens, not after them. Space after the ANNOTATIONS before ARRAY_DECLARATOR and INDEX_OP will be ignored.

u: (NoWhitespaceBefore) Checks that there is no whitespace before a token. More specifically, it checks that it is not preceded with whitespace, or \(if linebreaks are allowed \) all characters on the line before are whitespace. To allow linebreaks before a token, set property allowLineBreaks to true. No check occurs before semi-colons in empty for loop initializers or conditions.

u: (no whitespace before) Checks that there is no whitespace before a token. More specifically, it checks that it is not preceded with whitespace, or \(if linebreaks are allowed \) all characters on the line before are whitespace. To allow linebreaks before a token, set property allowLineBreaks to true. No check occurs before semi-colons in empty for loop initializers or conditions.

u: (whitespace) Checks that there is no whitespace before a token. More specifically, it checks that it is not preceded with whitespace, or \(if linebreaks are allowed \) all characters on the line before are whitespace. To allow linebreaks before a token, set property allowLineBreaks to true. No check occurs before semi-colons in empty for loop initializers or conditions.

u: (OperatorWrap) Checks the policy on how to wrap lines on operators.

u: (operator wrap) Checks the policy on how to wrap lines on operators.

u: (WhitespaceAfter) Checks that a token is followed by whitespace.

u: (whitespace after) Checks that a token is followed by whitespace.

u: (WhitespaceAround) Checks that a token is surrounded by whitespace. Empty constructor, method, class, enum, interface, loop bodies (blocks), lambdas of the form

public MyClass \(\) \{\}      // empty constructor
public void func \(\) \{\}    // empty method
public interface Foo \{\} // empty interface
public class Foo \{\} // empty class
public enum Foo \{\} // empty enum
MyClass c = new MyClass \(\) \{\}; // empty anonymous class
while \( i = 1 \) \{\} // empty while loop
for \( int i = 1; i > 1; i++ \) \{\} // empty for loop
do \{\} while \( i = 1 \); // empty do-while loop
Runnable noop = \(\) -> \{\}; // empty lambda
public \@interface Beta \{\} // empty annotation type

may optionally be exempted from the policy using the allowEmptyMethods, allowEmptyConstructors , allowEmptyTypes, allowEmptyLoops allowEmptyLambdas and allowEmptyCatches properties.

This check does not flag as violation double brace initialization like:


new Properties \(\) \{\{
    setProperty \("key", "value"\);
\}\};

Parameter allowEmptyCatches allows to suppress violations when token list contains SLIST to check if beginning of block is surrounded by whitespace and catch block is empty, for example:


try \{
    k = 5 / i;
\} catch \( ArithmeticException ex \) \{\}

With this property turned off, this raises violation because the beginning of the catch block \( left curly bracket \) is not separated from the end of the catch block \( right curly bracket \).

u: (whitespace around) Checks that a token is surrounded by whitespace. Empty constructor, method, class, enum, interface, loop bodies (blocks), lambdas of the form

public MyClass \(\) \{\}      // empty constructor
public void func \(\) \{\}    // empty method
public interface Foo \{\} // empty interface
public class Foo \{\} // empty class
public enum Foo \{\} // empty enum
MyClass c = new MyClass \(\) \{\}; // empty anonymous class
while \( i = 1 \) \{\} // empty while loop
for \( int i = 1; i > 1; i++ \) \{\} // empty for loop
do \{\} while \( i = 1 \); // empty do-while loop
Runnable noop = \(\) -> \{\}; // empty lambda
public \@interface Beta \{\} // empty annotation type

may optionally be exempted from the policy using the allowEmptyMethods, allowEmptyConstructors , allowEmptyTypes, allowEmptyLoops allowEmptyLambdas and allowEmptyCatches properties.

This check does not flag as violation double brace initialization like:


new Properties \(\) \{\{
    setProperty \("key", "value"\);
\}\};

Parameter allowEmptyCatches allows to suppress violations when token list contains SLIST to check if beginning of block is surrounded by whitespace and catch block is empty, for example:


try \{
    k = 5 / i;
\} catch \( ArithmeticException ex \) \{\}

With this property turned off, this raises violation because the beginning of the catch block \( left curly bracket \) is not separated from the end of the catch block \( right curly bracket \).

u: (MethodParamPad) Checks the padding between the identifier of a method definition, constructor definition, method call, or constructor invocation; and the left parenthesis of the parameter list. That is, if the identifier and left parenthesis are on the same line, checks whether a space is required immediately after the identifier or such a space is forbidden. If they are not on the same line, reports an error, unless configured to allow line breaks. To allow linebreaks after the identifier, set property allowLineBreaks to true.

u: (method param pad) Checks the padding between the identifier of a method definition, constructor definition, method call, or constructor invocation; and the left parenthesis of the parameter list. That is, if the identifier and left parenthesis are on the same line, checks whether a space is required immediately after the identifier or such a space is forbidden. If they are not on the same line, reports an error, unless configured to allow line breaks. To allow linebreaks after the identifier, set property allowLineBreaks to true.

u: (GenericWhitespace) Checks that the whitespace around the Generic tokens \(angle brackets \) "&lt;" and ">" are correct to the typical convention. The convention is not configurable.

Left angle bracket \("&lt;"\):

should be preceded with whitespace only in generic methods definitions.
should not be preceded with whitespace when it is precede method name or following type name.
should not be followed with whitespace in all cases.
Right angle bracket \(">"\):

should not be preceded with whitespace in all cases.
should be followed with whitespace in almost all cases, except diamond operators and when preceding method name.
Examples with correct spacing:

public void &lt;K, V extends Number> boolean foo \(K, V \) \{\} // Generic methods definitions
class name&lt;T1, T2, ..., Tn> \{\}                         // Generic type definition
OrderedPair&lt;String, Box&lt;Integer>> p;                   // Generic type reference
boolean same = Util.&lt;Integer, String>compare \( p1, p2 \);  // Generic preceded method name
Pair&lt;Integer, String> p1 = new Pair<> \( 1, "apple" \);     // Diamond operator
List&lt;T> list = ImmutableList.Builder&lt;T>::new;          // Method reference
sort \( list, Comparable::&lt;String>compareTo \);             // Method reference

u: (generic whitespace) Checks that the whitespace around the Generic tokens \(angle brackets \) "&lt;" and ">" are correct to the typical convention. The convention is not configurable.

Left angle bracket \("&lt;"\):

should be preceded with whitespace only in generic methods definitions.
should not be preceded with whitespace when it is precede method name or following type name.
should not be followed with whitespace in all cases.
Right angle bracket \(">"\):

should not be preceded with whitespace in all cases.
should be followed with whitespace in almost all cases, except diamond operators and when preceding method name.
Examples with correct spacing:

public void &lt;K, V extends Number> boolean foo \(K, V \) \{\} // Generic methods definitions
class name&lt;T1, T2, ..., Tn> \{\}                         // Generic type definition
OrderedPair&lt;String, Box&lt;Integer>> p;                   // Generic type reference
boolean same = Util.&lt;Integer, String>compare \( p1, p2 \);  // Generic preceded method name
Pair&lt;Integer, String> p1 = new Pair<> \( 1, "apple" \);     // Diamond operator
List&lt;T> list = ImmutableList.Builder&lt;T>::new;          // Method reference
sort \( list, Comparable::&lt;String>compareTo \);             // Method reference

u: (ParenPad) Checks the policy on the padding of parentheses; i.e. whether a space is required after a left parenthesis and before a right parenthesis, or such spaces are forbidden. No check occurs at the right parenthesis after an empty for iterator, at the left parenthesis before an empty for initialization, or at the right parenthesis of a try-with-resources resource specification where the last resource variable has a trailing semi-colon. Use Check EmptyForIteratorPad to validate empty for iterators and EmptyForInitializerPad to validate empty for initializers. Typecasts are also not checked, as there is TypecastParenPad to validate them.

u: (paren pad) Checks the policy on the padding of parentheses; i.e. whether a space is required after a left parenthesis and before a right parenthesis, or such spaces are forbidden. No check occurs at the right parenthesis after an empty for iterator, at the left parenthesis before an empty for initialization, or at the right parenthesis of a try-with-resources resource specification where the last resource variable has a trailing semi-colon. Use Check EmptyForIteratorPad to validate empty for iterators and EmptyForInitializerPad to validate empty for initializers. Typecasts are also not checked, as there is TypecastParenPad to validate them.

u: (ModifierOrder) Checks that the order of modifiers conforms to the suggestions in the Java Language specification, sections 8.1.1, 8.3.1, 8.4.3 and 9.4. The correct order is:

public
protected
private
abstract
default
static
final
transient
volatile
synchronized
native
strictfp

u: (modifier order) Checks that the order of modifiers conforms to the suggestions in the Java Language specification, sections 8.1.1, 8.3.1, 8.4.3 and 9.4. The correct order is:

public
protected
private
abstract
default
static
final
transient
volatile
synchronized
native
strictfp

u: (RedundantModifier) <p>
          Checks that the order of modifiers conforms to the suggestions in
          the <a class="externalLink" href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html">Java
          Language specification, sections 8.1.1, 8.3.1, 8.4.3</a> and <a class="externalLink" href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html">
          9.4</a>. The correct order is:
        </p>


<ol style="list-style-type: decimal">

<li>
            <tt>public</tt>
          </li>

<li>
            <tt>protected</tt>
          </li>

<li>
            <tt>private</tt>
          </li>

<li>
            <tt>abstract</tt>
          </li>

<li>
            <tt>default</tt>
          </li>

<li>
            <tt>static</tt>
          </li>

<li>
            <tt>final</tt>
          </li>

<li>
            <tt>transient</tt>
          </li>

<li>
            <tt>volatile</tt>
          </li>

<li>
            <tt>synchronized</tt>
          </li>

<li>
            <tt>native</tt>
          </li>

<li>
            <tt>strictfp</tt>
          </li>
        </ol>


<p>
          ATTENTION: We skip <a class="externalLink" href="http://www.oracle.com/technetwork/articles/java/ma14-architect-annotations-2177655.html">
          type annotations</a> from validation.
        </p>

      </div>


<div class="section">
<h3><a name="Examples"></a>Examples</h3>

<p> To configure the check: </p>

<div class="source">
<pre>
&lt;module name=&quot;ModifierOrder&quot;/&gt;
        </pre></div>
      </div>


<div class="section">
<h3><a name="Example_of_Usage"></a>Example of Usage</h3>

<ul>

<li>
            <a class="externalLink" href="https://github.com/search?q=path%3Asrc%2Fmain%2Fresources+filename%3Agoogle_checks.xml+repo%3Acheckstyle%2Fcheckstyle+ModifierOrder">
            Google Style</a>
          </li>

<li>
            <a class="externalLink" href="https://github.com/search?q=path%3Asrc%2Fmain%2Fresources+filename%3Asun_checks.xml+repo%3Acheckstyle%2Fcheckstyle+ModifierOrder">
            Sun Style</a>
          </li>

<li>
            <a class="externalLink" href="https://github.com/search?q=path%3Aconfig+filename%3Acheckstyle_checks.xml+repo%3Acheckstyle%2Fcheckstyle+ModifierOrder">
            Checkstyle Style</a>
          </li>
        </ul>
      </div>


<div class="section">
<h3><a name="Error_Messages"></a>Error Messages</h3>

<ul>

<li>
            <a class="externalLink" href="https://github.com/search?q=path%3Asrc%2Fmain%2Fresources%2Fcom%2Fpuppycrawl%2Ftools%2Fcheckstyle%2Fchecks%2Fmodifier+filename%3Amessages*.properties+repo%3Acheckstyle%2Fcheckstyle+%22annotation.order%22">
            annotation.order</a>
          </li>

<li>
            <a class="externalLink" href="https://github.com/search?q=path%3Asrc%2Fmain%2Fresources%2Fcom%2Fpuppycrawl%2Ftools%2Fcheckstyle%2Fchecks%2Fmodifier+filename%3Amessages*.properties+repo%3Acheckstyle%2Fcheckstyle+%22mod.order%22">
            mod.order</a>
          </li>
        </ul>

<p>
          All messages can be customized if the default message doesn't suit you.
          Please <a href="config.html#Custom_messages">see the documentation</a> to learn how to.
        </p>
      </div>


<div class="section">
<h3><a name="Package"></a>Package</h3>

<p> com.puppycrawl.tools.checkstyle.checks.modifier </p>
      </div>


<div class="section">
<h3><a name="Parent_Module"></a>Parent Module</h3>

<p>
          <a href="config.html#TreeWalker">TreeWalker</a>
        </p>
      </div>
    </div>


<div class="section">
<h2><a name="RedundantModifier"></a>RedundantModifier</h2>


<div class="section">
<h3><a name="Description"></a>Description</h3>

<p>Since Checkstyle 3.0</p>

<p>
          Checks for redundant modifiers in:
        </p>

<ol style="list-style-type: decimal">

<li>Interface and annotation definitions.</li>

<li>Final modifier on methods of final and anonymous classes.</li>

<li>
            Inner <tt>interface</tt> declarations that are declared
            as <tt>static</tt>.
          </li>

<li>Class constructors.</li>

<li>
            Nested <tt>enum</tt> definitions that are declared
            as <tt>static</tt>.
          </li>
        </ol>

<p>
          Rationale: The Java Language Specification strongly
          discourages the usage of <tt>public</tt> and <tt>abstract</tt> for method
          declarations in interface definitions as a matter of style.
        </p>


<p>
          Interfaces by definition are abstract so the <tt>abstract</tt>
          modifier on the interface is redundant.
        </p>


<p>
          Classes inside of interfaces by definition are public and static,
          so the <tt>public</tt> and <tt>static</tt> modifiers
          on the inner classes are redundant. On the other hand, classes
          inside of interfaces can be abstract or non abstract.
          So, <tt>abstract</tt> modifier is allowed.
        </p>


<p>
          Fields in interfaces and annotations are automatically
          public, static and final, so these modifiers are redundant as
          well.
        </p>


<p>
          As annotations are a form of interface, their fields are also
          automatically public, static and final just as their
          annotation fields are automatically public and abstract.
        </p>


<p>
          Enums by definition are static implicit subclasses of java.lang.Enum&lt;E&gt;.
          So, the <tt>static</tt> modifier on the enums is redundant. In addition,
          if enum is inside of interface, <tt>public</tt> modifier is also redundant.
        </p>


<p>
          Enums can also contain abstract methods and methods which can be overridden by the declared
          enumeration fields.
          See the following example:
        </p>


<div class="source">
<pre>
public enum EnumClass \{
  FIELD_1,
  FIELD_2 \{
    \@Override
    public final void method1 \(\) \{\} // violation expected
  \};

  public void method1 \(\) \{\}
  public final void method2 \(\) \{\} // no violation expected
\}
        </pre></div>


<p>
          Since these methods can be overridden in these situations, the final methods are not
          marked as redundant even though they can't be extended by other classes/enums.
        </p>


<p>
          Nested <tt>enum</tt> types are always static by default.
        </p>


<p>
          Final classes by definition cannot be extended so the <tt>final</tt>
          modifier on the method of a final class is redundant.
        </p>


<p>
          Public modifier for constructors in non-public non-protected classes
          is always obsolete:
        </p>


<div class="source">
<pre>
public class PublicClass \{
  public PublicClass \(\) \{\} // OK
\}

class PackagePrivateClass \{
  public PackagePrivateClass \(\) \{\} // violation expected
\}
        </pre></div>


<p>There is no violation in the following example,
          because removing public modifier from ProtectedInnerClass
          constructor will make this code not compiling:
        </p>


<div class="source">
<pre>
package a ;
public class ClassExample \{
  protected class ProtectedInnerClass \{
    public ProtectedInnerClass \(\) \{\}
  \}
\}

package b;
import a.ClassExample;
public class ClassExtending extends ClassExample \{
  ProtectedInnerClass pc = new ProtectedInnerClass \(\);
\}
        </pre></div>
      </div></div>

u: (redundant modifier) <p>
          Checks that the order of modifiers conforms to the suggestions in
          the <a class="externalLink" href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html">Java
          Language specification, sections 8.1.1, 8.3.1, 8.4.3</a> and <a class="externalLink" href="https://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html">
          9.4</a>. The correct order is:
        </p>


<ol style="list-style-type: decimal">

<li>
            <tt>public</tt>
          </li>

<li>
            <tt>protected</tt>
          </li>

<li>
            <tt>private</tt>
          </li>

<li>
            <tt>abstract</tt>
          </li>

<li>
            <tt>default</tt>
          </li>

<li>
            <tt>static</tt>
          </li>

<li>
            <tt>final</tt>
          </li>

<li>
            <tt>transient</tt>
          </li>

<li>
            <tt>volatile</tt>
          </li>

<li>
            <tt>synchronized</tt>
          </li>

<li>
            <tt>native</tt>
          </li>

<li>
            <tt>strictfp</tt>
          </li>
        </ol>


<p>
          ATTENTION: We skip <a class="externalLink" href="http://www.oracle.com/technetwork/articles/java/ma14-architect-annotations-2177655.html">
          type annotations</a> from validation.
        </p>

      </div>


<div class="section">
<h3><a name="Examples"></a>Examples</h3>

<p> To configure the check: </p>

<div class="source">
<pre>
&lt;module name=&quot;ModifierOrder&quot;/&gt;
        </pre></div>
      </div>


<div class="section">
<h3><a name="Example_of_Usage"></a>Example of Usage</h3>

<ul>

<li>
            <a class="externalLink" href="https://github.com/search?q=path%3Asrc%2Fmain%2Fresources+filename%3Agoogle_checks.xml+repo%3Acheckstyle%2Fcheckstyle+ModifierOrder">
            Google Style</a>
          </li>

<li>
            <a class="externalLink" href="https://github.com/search?q=path%3Asrc%2Fmain%2Fresources+filename%3Asun_checks.xml+repo%3Acheckstyle%2Fcheckstyle+ModifierOrder">
            Sun Style</a>
          </li>

<li>
            <a class="externalLink" href="https://github.com/search?q=path%3Aconfig+filename%3Acheckstyle_checks.xml+repo%3Acheckstyle%2Fcheckstyle+ModifierOrder">
            Checkstyle Style</a>
          </li>
        </ul>
      </div>


<div class="section">
<h3><a name="Error_Messages"></a>Error Messages</h3>

<ul>

<li>
            <a class="externalLink" href="https://github.com/search?q=path%3Asrc%2Fmain%2Fresources%2Fcom%2Fpuppycrawl%2Ftools%2Fcheckstyle%2Fchecks%2Fmodifier+filename%3Amessages*.properties+repo%3Acheckstyle%2Fcheckstyle+%22annotation.order%22">
            annotation.order</a>
          </li>

<li>
            <a class="externalLink" href="https://github.com/search?q=path%3Asrc%2Fmain%2Fresources%2Fcom%2Fpuppycrawl%2Ftools%2Fcheckstyle%2Fchecks%2Fmodifier+filename%3Amessages*.properties+repo%3Acheckstyle%2Fcheckstyle+%22mod.order%22">
            mod.order</a>
          </li>
        </ul>

<p>
          All messages can be customized if the default message doesn't suit you.
          Please <a href="config.html#Custom_messages">see the documentation</a> to learn how to.
        </p>
      </div>


<div class="section">
<h3><a name="Package"></a>Package</h3>

<p> com.puppycrawl.tools.checkstyle.checks.modifier </p>
      </div>


<div class="section">
<h3><a name="Parent_Module"></a>Parent Module</h3>

<p>
          <a href="config.html#TreeWalker">TreeWalker</a>
        </p>
      </div>
    


<div class="section">
<h2><a name="RedundantModifier"></a>RedundantModifier</h2>


<div class="section">
<h3><a name="Description"></a>Description</h3>

<p>Since Checkstyle 3.0</p>

<p>
          Checks for redundant modifiers in:
        </p>

<ol style="list-style-type: decimal">

<li>Interface and annotation definitions.</li>

<li>Final modifier on methods of final and anonymous classes.</li>

<li>
            Inner <tt>interface</tt> declarations that are declared
            as <tt>static</tt>.
          </li>

<li>Class constructors.</li>

<li>
            Nested <tt>enum</tt> definitions that are declared
            as <tt>static</tt>.
          </li>
        </ol>

<p>
          Rationale: The Java Language Specification strongly
          discourages the usage of <tt>public</tt> and <tt>abstract</tt> for method
          declarations in interface definitions as a matter of style.
        </p>


<p>
          Interfaces by definition are abstract so the <tt>abstract</tt>
          modifier on the interface is redundant.
        </p>


<p>
          Classes inside of interfaces by definition are public and static,
          so the <tt>public</tt> and <tt>static</tt> modifiers
          on the inner classes are redundant. On the other hand, classes
          inside of interfaces can be abstract or non abstract.
          So, <tt>abstract</tt> modifier is allowed.
        </p>


<p>
          Fields in interfaces and annotations are automatically
          public, static and final, so these modifiers are redundant as
          well.
        </p>


<p>
          As annotations are a form of interface, their fields are also
          automatically public, static and final just as their
          annotation fields are automatically public and abstract.
        </p>


<p>
          Enums by definition are static implicit subclasses of java.lang.Enum&lt;E&gt;.
          So, the <tt>static</tt> modifier on the enums is redundant. In addition,
          if enum is inside of interface, <tt>public</tt> modifier is also redundant.
        </p>


<p>
          Enums can also contain abstract methods and methods which can be overridden by the declared
          enumeration fields.
          See the following example:
        </p>


<div class="source">
<pre>
public enum EnumClass \{
  FIELD_1,
  FIELD_2 \{
    \@Override
    public final void method1 \(\) \{\} // violation expected
  \};

  public void method1 \(\) \{\}
  public final void method2 \(\) \{\} // no violation expected
\}
        </pre></div>


<p>
          Since these methods can be overridden in these situations, the final methods are not
          marked as redundant even though they can't be extended by other classes/enums.
        </p>


<p>
          Nested <tt>enum</tt> types are always static by default.
        </p>


<p>
          Final classes by definition cannot be extended so the <tt>final</tt>
          modifier on the method of a final class is redundant.
        </p>


<p>
          Public modifier for constructors in non-public non-protected classes
          is always obsolete:
        </p>


<div class="source">
<pre>
public class PublicClass \{
  public PublicClass \(\) \{\} // OK
\}

class PackagePrivateClass \{
  public PackagePrivateClass \(\) \{\} // violation expected
\}
        </pre></div>


<p>There is no violation in the following example,
          because removing public modifier from ProtectedInnerClass
          constructor will make this code not compiling:
        </p>


<div class="source">
<pre>
package a\;
public class ClassExample \{
  protected class ProtectedInnerClass \{
    public ProtectedInnerClass \(\) \{\}
  \}
\}

package b;
import a.ClassExample;
public class ClassExtending extends ClassExample \{
  ProtectedInnerClass pc = new ProtectedInnerClass \(\);
\}
        </pre></div>
      </div></div></div>

u: (LeftCurly) Checks for the placement of left curly braces \( '\{' \) for code blocks.

u: (left curly) Checks for the placement of left curly braces \( '\{' \) for code blocks.

u: (NeedBraces)	Checks for braces around code blocks.

u: (need braces)	Checks for braces around code blocks.

u: (RightCurly) Checks the placement of right curly braces \( \} \) for if-else, try-catch-finally blocks, while-loops, for-loops, method definitions, class definitions, constructor definitions, instance and static initialization blocks.

u: (right curly) Checks the placement of right curly braces \( \} \) for if-else, try-catch-finally blocks, while-loops, for-loops, method definitions, class definitions, constructor definitions, instance and static initialization blocks.

u: (MultipleVariableDeclarations) Checks that each variable declaration is in its own statement and on its own line.
<br/>
Rationale: the Java code conventions chapter 6.1 recommends that declarations should be one per line/statement.

u: (multiple variable declarations) Checks that each variable declaration is in its own statement and on its own line.
<br/>
Rationale: the Java code conventions chapter 6.1 recommends that declarations should be one per line/statement.

u: (OneStatementPerLine) Checks that there is only one statement per line.
<br/>
Rationale: It's very difficult to read multiple statements on one line.
<br/>
In the Java programming language, statements are the fundamental unit of execution. All statements except blocks are terminated by a semicolon. Blocks are denoted by open and close curly braces.
<br/>
OneStatementPerLineCheck checks the following types of statements: variable declaration statements, empty statements, import statements, assignment statements, expression statements, increment statements, object creation statements, 'for loop' statements, 'break' statements, 'continue' statements, 'return' statements.

u: (one statement per line) Checks that there is only one statement per line.
<br/>
Rationale: It's very difficult to read multiple statements on one line.
<br/>
In the Java programming language, statements are the fundamental unit of execution. All statements except blocks are terminated by a semicolon. Blocks are denoted by open and close curly braces.
<br/>
OneStatementPerLineCheck checks the following types of statements: variable declaration statements, empty statements, import statements, assignment statements, expression statements, increment statements, object creation statements, 'for loop' statements, 'break' statements, 'continue' statements, 'return' statements.

u: (UnnecessaryParentheses) Checks for the use of unnecessary parentheses.

u: (unnecessary parentheses) Checks for the use of unnecessary parentheses.

u: (ArrayTypeStyle) Checks the style of array type definitions. Some like Java style: public static void main \(String\[\] args\) and some like C style: public static void main \(String args\[\]\).

u: (array type style) Checks the style of array type definitions. Some like Java style: public static void main \(String\[\] args\) and some like C style: public static void main \(String args\[\]\).

u: (UpperEll) Checks that long constants are defined with an upper ell. That is ' L' and not 'l'. This is in accordance with the Java Language Specification, Section 3.10.1.

The capital L looks a lot like 1.

u: (upper ell) Checks that long constants are defined with an upper ell. That is ' L' and not 'l'. This is in accordance with the Java Language Specification, Section 3.10.1.

The capital L looks a lot like 1.

# Formatting PMD
u: (IfStmtsMustUseBraces) <p>
Avoid using if statements without using curly braces.
     </p>
<p>Example:</p>

    <div class="source"><pre>


 public class Foo \{
   public void bar \(\) \{
     int x = 0;
     if \(foo \) x++;
   \}
 \}


            </pre></div>

u: (if stmts must use braces) <p>
Avoid using if statements without using curly braces.
     </p>
<p>Example:</p>

    <div class="source"><pre>


 public class Foo \{
   public void bar \(\) \{
     int x = 0;
     if \(foo \) x++;
   \}
 \}


            </pre></div>

u: (WhileLoopsMustUseBracesRule) Avoid using 'while' statements without using curly braces.
<div class="source"><pre>

public void doSomething \(\) \{
  while \(true \)
      x++;
\}


            </pre></div>

u: (while loops must use braces rule) Avoid using 'while' statements without using curly braces.
<div class="source"><pre>

public void doSomething \(\) \{
  while \(true \)
      x++;
\}


            </pre></div>

u: (IfElseStmtsMustUseBracesRule) Avoid using if..else statements without using curly braces.
<div class="source"><pre>

 public void doSomething \(\) \{
   // this is OK
   if \(foo \) x++;
   // but this is not
   if \(foo \)
       x=x+1;
   else
       x=x-1;
 \}


            </pre></div>

u: (if else stmts must use braces rule) Avoid using if..else statements without using curly braces.
<div class="source"><pre>

 public void doSomething \(\) \{
   // this is OK
   if \(foo \) x++;
   // but this is not
   if \(foo \)
       x=x+1;
   else
       x=x-1;
 \}


            </pre></div>

u: 	(ForLoopsMustUseBracesRule) Avoid using 'for' statements without using curly braces.
<div class="source"><pre>

public void foo \(\) \{
 for \(int i=0; i&lt;42;i++ \)
   foo \(\);
\}


            </pre></div>

u: 	(for loops must use braces rule) Avoid using 'for' statements without using curly braces.
<div class="source"><pre>

public void foo \(\) \{
 for \(int i=0; i&lt;42;i++ \)
   foo \(\);
\}


            </pre></div>

u: (SuspiciousOctalEscape) A suspicious octal escape sequence was found inside a String literal. The Java language specification \(section 3.10.6 \) says an octal escape sequence inside a literal String shall consist of a backslash followed by: OctalDigit | OctalDigit OctalDigit | ZeroToThree OctalDigit OctalDigit Any octal escape sequence followed by non-octal digits can be confusing, e.g. "\038" is interpreted as the octal escape sequence "\03" followed by the literal character "8".

u: (suspicious octal escape) A suspicious octal escape sequence was found inside a String literal. The Java language specification \(section 3.10.6 \) says an octal escape sequence inside a literal String shall consist of a backslash followed by: OctalDigit | OctalDigit OctalDigit | ZeroToThree OctalDigit OctalDigit Any octal escape sequence followed by non-octal digits can be confusing, e.g. "\038" is interpreted as the octal escape sequence "\03" followed by the literal character "8".

u: (AvoidUsingOctalValues) Integer literals should not start with zero since this denotes that the rest of literal will be interpreted as an octal value.

u: (avoid using octal values) Integer literals should not start with zero since this denotes that the rest of literal will be interpreted as an octal value.

u: (AvoidDecimalLiteralsInBigDecimalConstructor) One might assume that "new BigDecimal \(.1 \)" is exactly equal to .1, but it is actually equal to .1000000000000000055511151231257827021181583404541015625. This is so because .1 cannot be represented exactly as a double (or, for that matter, as a binary fraction of any finite length). Thus, the long value that is being passed in to the constructor is not exactly equal to .1, appearances notwithstanding. The (String) constructor, on the other hand, is perfectly predictable: 'new BigDecimal \(".1" \)' is exactly equal to .1, as one would expect. Therefore, it is generally recommended that the \(String \) constructor be used in preference to this one.

u: (avoid decimal literals in big decimal constructor) One might assume that "new BigDecimal \(.1 \)" is exactly equal to .1, but it is actually equal to .1000000000000000055511151231257827021181583404541015625. This is so because .1 cannot be represented exactly as a double (or, for that matter, as a binary fraction of any finite length). Thus, the long value that is being passed in to the constructor is not exactly equal to .1, appearances notwithstanding. The (String) constructor, on the other hand, is perfectly predictable: 'new BigDecimal \(".1" \)' is exactly equal to .1, as one would expect. Therefore, it is generally recommended that the \(String \) constructor be used in preference to this one.

# Coding Checkstyle
u: (EmptyBlock) Checks for empty blocks. This check does not validate sequential blocks.

Sequential blocks won't be checked. Also, no violations for fallthrough.

u: (empty block) Checks for empty blocks. This check does not validate sequential blocks.

Sequential blocks won't be checked. Also, no violations for fallthrough.

u: (CovariantEquals) Checks that classes which define a covariant equals \(\) method also override method equals \( Object g \).
Covariant equals \(\) - method that is similar to equals \( Object \), but with a covariant parameter type \( any subtype of Object \).
Notice: the enums are also checked, even though they cannot override equals \( Object \). The reason is to point out that implementing equals \(\) in enums is considered an awful practice: it may cause having two different enum values that are equal using covariant enum method, and not equal when compared normally.

Inspired by Finding Bugs is Easy, chapter '2.3.1 Bad Covariant Definition of Equals \( Eq \)':

Java classes may override the equals \( Object \) method to define a predicate for object equality. This method is used by many of the Java runtime library classes; for example, to implement generic containers.

Programmers sometimes mistakenly use the type of their class Foo as the type of the parameter to equals \(\):

public boolean equals \( Foo obj \) \{ ... \}

This covariant version of equals \(\) does not override the version in the Object class, and it may lead to unexpected behavior at runtime, especially if the class is used with one of the standard collection classes which expect that the standard equals \( Object \) method is overridden.

This kind of bug is not obvious because it looks correct, and in circumstances where the class is accessed through the references of the class type \( rather than a supertype \), it will work correctly. However, the first time it is used in a container, the behavior might be mysterious. For these reasons, this type of bug can elude testing and code inspections.

u: (covariant equals) Checks that classes which define a covariant equals \(\) method also override method equals \( Object g \).
Covariant equals \(\) - method that is similar to equals \( Object \), but with a covariant parameter type \( any subtype of Object \).
Notice: the enums are also checked, even though they cannot override equals \( Object \). The reason is to point out that implementing equals \(\) in enums is considered an awful practice: it may cause having two different enum values that are equal using covariant enum method, and not equal when compared normally.

Inspired by Finding Bugs is Easy, chapter '2.3.1 Bad Covariant Definition of Equals \( Eq \)':

Java classes may override the equals \( Object \) method to define a predicate for object equality. This method is used by many of the Java runtime library classes; for example, to implement generic containers.

Programmers sometimes mistakenly use the type of their class Foo as the type of the parameter to equals \(\):

public boolean equals \( Foo obj \) \{ ... \}

This covariant version of equals \(\) does not override the version in the Object class, and it may lead to unexpected behavior at runtime, especially if the class is used with one of the standard collection classes which expect that the standard equals \( Object \) method is overridden.

This kind of bug is not obvious because it looks correct, and in circumstances where the class is accessed through the references of the class type \( rather than a supertype \), it will work correctly. However, the first time it is used in a container, the behavior might be mysterious. For these reasons, this type of bug can elude testing and code inspections.

u: (EmptyStatement) Detects empty statements \(standalone ";" semicolon \).

u: (empty statement) Detects empty statements \(standalone ";" semicolon \).

u: (HiddenField)   Checks that a local variable or a parameter does not shadow a field that is defined in the same class.

u: (hidden field)   Checks that a local variable or a parameter does not shadow a field that is defined in the same class.

u: (MagicNumber) Checks that there are no "magic numbers" where a magic number is a numeric literal that is not defined as a constant. By default, -1, 0, 1, and 2 are not considered to be magic numbers.

It is fine to have one constant defining multiple numeric literals within one expression:

static final int SECONDS_PER_DAY = 24 * 60 * 60;
static final double SPECIAL_RATIO = 4.0 / 3.0;
static final double SPECIAL_SUM = 1 + Math.E;
static final double SPECIAL_DIFFERENCE = 4 - Math.PI;
static final Border STANDARD_BORDER = BorderFactory.createEmptyBorder \(3, 3, 3, 3 \);
static final Integer ANSWER_TO_THE_ULTIMATE_QUESTION_OF_LIFE = new Integer \( 42 \);

u: (magic number) Checks that there are no "magic numbers" where a magic number is a numeric literal that is not defined as a constant. By default, -1, 0, 1, and 2 are not considered to be magic numbers.

It is fine to have one constant defining multiple numeric literals within one expression:

static final int SECONDS_PER_DAY = 24 * 60 * 60;
static final double SPECIAL_RATIO = 4.0 / 3.0;
static final double SPECIAL_SUM = 1 + Math.E;
static final double SPECIAL_DIFFERENCE = 4 - Math.PI;
static final Border STANDARD_BORDER = BorderFactory.createEmptyBorder \(3, 3, 3, 3 \);
static final Integer ANSWER_TO_THE_ULTIMATE_QUESTION_OF_LIFE = new Integer \( 42 \);

u: (SimplifyBooleanExpressions) Checks for over-complicated boolean expressions. Currently finds code like if \(b == true \), b || true, !false, etc.

Rationale: Complex boolean logic makes code hard to understand and maintain.

u: (simplify boolean expressions) Checks for over-complicated boolean expressions. Currently finds code like if \(b == true \), b || true, !false, etc.

Rationale: Complex boolean logic makes code hard to understand and maintain.

u: (SimplifyBooleanReturns) Checks for over-complicated boolean return statements. For example the following code

if \(valid \(\)\)
  return false;
else
  return true;

could be written as

return !valid \(\);

u: (simplify boolean returns) Checks for over-complicated boolean return statements. For example the following code

if \(valid \(\)\)
  return false;
else
  return true;

could be written as

return !valid \(\);

u: (StringLiteralEquality) Checks that string literals are not used with == or !=.

Rationale: Novice Java programmers often use code like:

if \(x == "something"\)

when they mean

if \("something".equals \(x \) \)

u: (string literal equality) Checks that string literals are not used with == or !=.

Rationale: Novice Java programmers often use code like:

if \(x == "something"\)

when they mean

if \("something".equals \(x \) \)

u: (AvoidNestedBlocks) <p>
          Finds nested blocks, i.e. blocks that are used freely in the code.
        </p>


<p>
          Rationale: Nested blocks are often leftovers from the
          debugging process, they confuse the reader.
        </p>


<p>
          For example this Check finds the obsolete braces in
        </p>

<div class="source">
<pre>
public void guessTheOutput \(\)
\{
  int whichIsWhich = 0;
  \{
      int whichIsWhich = 2;
  \}
  System.out.println \(&quot;value = &quot; + whichIsWhich \);
\}
        </pre></div>


<p> and debugging / refactoring leftovers such as </p>

<div class="source">
<pre>
// if \( conditionThatIsNotUsedAnyLonger \)
\{
  System.out.println \( &quot;unconditional&quot; \);
\}
        </pre></div>


<p>
          A case in a switch statement does not implicitly form a block.
          Thus to be able to introduce local variables that have case
          scope it is necessary to open a nested block. This is
          supported, set the allowInSwitchCase property to true and
          include all statements of the case in the block.
        </p>

<div class="source">
<pre>
switch \(a \)
\{
  case 0:
    // Never OK, break outside block
    \{
      x = 1;
    \}
    break;
  case 1:
    // Never OK, statement outside block
    System.out.println \( &quot;Hello&quot; \);
    \{
      x = 2;
      break;
    \}
  case 1:
    // OK if allowInSwitchCase is true
    \{
      System.out.println \( &quot;Hello&quot; \);
      x = 2;
      break;
    \}
\}
        </pre></div>
      </div>

u: (avoid nested blocks) <p>
		  Finds nested blocks, i.e. blocks that are used freely in the code.
		</p>


<p>
          Rationale: Nested blocks are often leftovers from the
          debugging process, they confuse the reader.
        </p>


<p>
          For example this Check finds the obsolete braces in
        </p>

<div class="source">
<pre>
public void guessTheOutput \(\)
\{
  int whichIsWhich = 0;
  \{
      int whichIsWhich = 2;
  \}
  System.out.println \(&quot;value = &quot; + whichIsWhich \);
\}
        </pre></div>


<p> and debugging / refactoring leftovers such as </p>

<div class="source">
<pre>
// if \( conditionThatIsNotUsedAnyLonger \)
\{
  System.out.println \( &quot;unconditional&quot; \);
\}
        </pre></div>


<p>
          A case in a switch statement does not implicitly form a block.
          Thus to be able to introduce local variables that have case
          scope it is necessary to open a nested block. This is
          supported, set the allowInSwitchCase property to true and
          include all statements of the case in the block.
        </p>

<div class="source">
<pre>
switch \(a \)
\{
  case 0:
    // Never OK, break outside block
    \{
      x = 1;
    \}
    break;
  case 1:
    // Never OK, statement outside block
    System.out.println \( &quot;Hello&quot; \);
    \{
      x = 2;
      break;
    \}
  case 1:
    // OK if allowInSwitchCase is true
    \{
      System.out.println \( &quot;Hello&quot; \);
      x = 2;
      break;
    \}
\}
        </pre></div>
      </div>

u: (DefaultComesLast) Check that the default is after all the cases in a switch statement.

Rationale: Java allows default anywhere within the switch statement. But it is more readable if it comes after the last case.

u: (default comes last) Check that the default is after all the cases in a switch statement.

Rationale: Java allows default anywhere within the switch statement. But it is more readable if it comes after the last case.

u: (MissingCtor)  Checks that classes \(except abstract ones \) define a constructor and don't rely on the default one.

u: (missing ctor)  Checks that classes \(except abstract ones \) define a constructor and don't rely on the default one.

u: (FallThrough) Checks for fall-through in switch statements. Finds locations where a case contains Java code but lacks a break, return, throw or continue statement.

The check honors special comments to suppress the warning. By default the text "fallthru", "fall through", "fallthrough", "falls through" and "fallsthrough" are recognized \(case sensitive \). The comment containing these words must be all on one line, and must be on the last non-empty line before the case triggering the warning or on the same line before the case \(ugly, but possible \).

u: (fall through) Checks for fall-through in switch statements. Finds locations where a case contains Java code but lacks a break, return, throw or continue statement.

The check honors special comments to suppress the warning. By default the text "fallthru", "fall through", "fallthrough", "falls through" and "fallsthrough" are recognized \(case sensitive \). The comment containing these words must be all on one line, and must be on the last non-empty line before the case triggering the warning or on the same line before the case \(ugly, but possible \).

u: (RequireThis) Checks that references to instance variables and methods of the present object are explicitly of the form "this.varName" or "this.methodName \(args\)" and that those references don't rely on the default behavior when "this." is absent.

Warning: the Check is very controversial if 'validateOnlyOverlapping' option is set to 'false' and not that actual nowadays.

Rationale:

The same notation/habit for C++ and Java \(C++ have global methods, so having "this." do make sense in it to distinguish call of method of class instead of global \).
Non-IDE development \(ease of refactoring, some clearness to distinguish static and non-static methods \).

u: (require this) Checks that references to instance variables and methods of the present object are explicitly of the form "this.varName" or "this.methodName \(args\)" and that those references don't rely on the default behavior when "this." is absent.

Warning: the Check is very controversial if 'validateOnlyOverlapping' option is set to 'false' and not that actual nowadays.

Rationale:

The same notation/habit for C++ and Java \(C++ have global methods, so having "this." do make sense in it to distinguish call of method of class instead of global \).
Non-IDE development \(ease of refactoring, some clearness to distinguish static and non-static methods \).

u: (VisibilityModifier) Checks visibility of class members. Only static final, immutable or annotated by specified annotation members may be public; other class members must be private unless the property protectedAllowed or packageAllowed is set.

Public members are not flagged if the name matches the public member regular expression \(contains "^serialVersionUID$" by default \).

Note that Checkstyle 2 used to include "^f\[A-Z\]\[a-zA-Z0-9\]*$" in the default pattern to allow names used in container-managed persistence for Enterprise JavaBeans \(EJB \) 1.1 with the default settings. With EJB 2.0 it is no longer necessary to have public access for persistent fields, so the default has been changed.

Rationale: Enforce encapsulation.

Check also has options making it less strict:

ignoreAnnotationCanonicalNames - the list of annotations which ignore variables in consideration. If user will provide short annotation name that type will match to any named the same type without consideration of package

allowPublicFinalFields - which allows public final fields. Default value is false

allowPublicImmutableFields - which allows immutable fields to be declared as public if defined in final class. Default value is false

Field is known to be immutable if: - It's declared as final - Has either a primitive type or instance of class user defined to be immutable \(such as String, ImmutableCollection from Guava and etc \)

Classes known to be immutable are listed in immutableClassCanonicalNames by their canonical names.

Rationale: Forcing all fields of class to have private modified by default is good in most cases, but in some cases it drawbacks in too much boilerplate get/set code. One of such cases are immutable classes.

Restriction: Check doesn't check if class is immutable, there's no checking if accessory methods are missing and all fields are immutable, we only check if current field is immutable or final. Under the flag allowPublicImmutableFields, the enclosing class must also be final, to encourage immutability. Under the flag allowPublicFinalFields, the final modifier on the enclosing class is optional.

Star imports are out of scope of this Check. So if one of type imported via star import collides with user specified one by its short name - there won't be Check's violation.

u: (visibility modifier) Checks visibility of class members. Only static final, immutable or annotated by specified annotation members may be public; other class members must be private unless the property protectedAllowed or packageAllowed is set.

Public members are not flagged if the name matches the public member regular expression \(contains "^serialVersionUID$" by default \).

Note that Checkstyle 2 used to include "^f\[A-Z\]\[a-zA-Z0-9\]*$" in the default pattern to allow names used in container-managed persistence for Enterprise JavaBeans \(EJB \) 1.1 with the default settings. With EJB 2.0 it is no longer necessary to have public access for persistent fields, so the default has been changed.

Rationale: Enforce encapsulation.

Check also has options making it less strict:

ignoreAnnotationCanonicalNames - the list of annotations which ignore variables in consideration. If user will provide short annotation name that type will match to any named the same type without consideration of package

allowPublicFinalFields - which allows public final fields. Default value is false

allowPublicImmutableFields - which allows immutable fields to be declared as public if defined in final class. Default value is false

Field is known to be immutable if: - It's declared as final - Has either a primitive type or instance of class user defined to be immutable \(such as String, ImmutableCollection from Guava and etc \)

Classes known to be immutable are listed in immutableClassCanonicalNames by their canonical names.

Rationale: Forcing all fields of class to have private modified by default is good in most cases, but in some cases it drawbacks in too much boilerplate get/set code. One of such cases are immutable classes.

Restriction: Check doesn't check if class is immutable, there's no checking if accessory methods are missing and all fields are immutable, we only check if current field is immutable or final. Under the flag allowPublicImmutableFields, the enclosing class must also be final, to encourage immutability. Under the flag allowPublicFinalFields, the final modifier on the enclosing class is optional.

Star imports are out of scope of this Check. So if one of type imported via star import collides with user specified one by its short name - there won't be Check's violation.

u: (InnerAssignment) Checks for assignments in subexpressions, such as in String s = Integer.toString \(i = 2 \);.

Rationale: With the exception of for iterators and assignment in while idiom, all assignments should occur in their own top-level statement to increase readability. With inner assignments like the one given above, it is difficult to see all places where a variable is set.

Note: Check allows usage of the popular assignment in while idiom:

String line;
while \( \( line = bufferedReader.readLine\(\) \) != null \) \{
  // process the line
\}

Assignment inside a condition is not a problem here, as the assignment is surrounded by an extra pair of parentheses. The comparison is != null and there is no chance that intention was to write line == reader.readLine \(\).

u: (inner assignment) Checks for assignments in subexpressions, such as in String s = Integer.toString \(i = 2 \);.

Rationale: With the exception of for iterators and assignment in while idiom, all assignments should occur in their own top-level statement to increase readability. With inner assignments like the one given above, it is difficult to see all places where a variable is set.

Note: Check allows usage of the popular assignment in while idiom:

String line;
while \( \( line = bufferedReader.readLine\(\) \) != null \) \{
  // process the line
\}

Assignment inside a condition is not a problem here, as the assignment is surrounded by an extra pair of parentheses. The comparison is != null and there is no chance that intention was to write line == reader.readLine \(\).

u: (FileLength) Checks for long source files.

Rationale: If a source file becomes very long it is hard to understand. Therefore long classes should usually be refactored into several individual classes that focus on a specific task.

u: (file length) Checks for long source files.

Rationale: If a source file becomes very long it is hard to understand. Therefore long classes should usually be refactored into several individual classes that focus on a specific task.

u: (MethodLength) Checks for long methods.

Rationale: If a method becomes very long it is hard to understand. Therefore long methods should usually be refactored into several individual methods that focus on a specific task.

u: (method length) Checks for long methods.

Rationale: If a method becomes very long it is hard to understand. Therefore long methods should usually be refactored into several individual methods that focus on a specific task.

u: (ParameterNumber) Checks the number of parameters that a method or constructor has. The default allowable number of parameters is 7. To change the number of allowable parameters, set property max.

u: (parameter number) Checks the number of parameters that a method or constructor has. The default allowable number of parameters is 7. To change the number of allowable parameters, set property max.

# Coding PMD
u: (ForLoopShouldBeWhileLoop) Some for loops can be simplified to while loops - this makes them more concise.
<div class="source"><pre>

public class Foo \{
 void bar \(\) \{
  for \(;true; \) true; // No Init or Update part, may as well be: while \(true \)
 \}
\}


            </pre></div>

u: (for loop should be while loop) Some for loops can be simplified to while loops - this makes them more concise.
<div class="source"><pre>

public class Foo \{
 void bar \(\) \{
  for \(;true; \) true; // No Init or Update part, may as well be: while \(true \)
 \}
\}


            </pre></div>

u: (OverrideBothEqualsAndHashcode) Override both public boolean Object.equals \(Object other \), and public int Object.hashCode \(\), or override neither. Even if you are inheriting a hashCode \(\) from a parent class, consider implementing hashCode and explicitly delegating to your superclass.
<div class="source"><pre>

// this is bad
public class Bar \{
  public boolean equals \( Object o \) \{
      // do some comparison
  \}
\}

// and so is this
public class Baz \{
  public int hashCode \(\) \{
      // return some hash value
  \}
\}

// this is OK
public class Foo \{
  public boolean equals \( Object other \) \{
      // do some comparison
  \}
  public int hashCode \(\) \{
      // return some hash value
  \}
\}


            </pre></div>

u: (override both equals and hashcode) Override both public boolean Object.equals \(Object other \), and public int Object.hashCode \(\), or override neither. Even if you are inheriting a hashCode \(\) from a parent class, consider implementing hashCode and explicitly delegating to your superclass.
<div class="source"><pre>

// this is bad
public class Bar \{
  public boolean equals \( Object o \) \{
      // do some comparison
  \}
\}

// and so is this
public class Baz \{
  public int hashCode \(\) \{
      // return some hash value
  \}
\}

// this is OK
public class Foo \{
  public boolean equals \( Object other \) \{
      // do some comparison
  \}
  public int hashCode \(\) \{
      // return some hash value
  \}
\}


            </pre></div>

u: (DoubleCheckedLocking) void method \(\) \{ if \( x == null \) \{ synchronized \( this \)\{ if \( x == null \) \{ x = new | method \(\); \} \} \} 1. The error is when one uses the value assigned within a synchronized section, outside of a synchronized section. if \( x == null \) is outside of synchronized section x = new | method \(\);

Very very specific check for double checked locking.
<div class="source"><pre>

public class Foo \{
  Object baz;
  Object bar \(\) \{
    if \( baz == null \) \{ //baz may be non-null yet not fully created
      synchronized \( this \)\{
        if \( baz == null \)\{
          baz = new Object \(\);
        \}
      \}
    \}
    return baz;
  \}
\}


            </pre></div>

u: (double checked locking) void method \(\) \{ if \( x == null \) \{ synchronized \( this \)\{ if \( x == null \) \{ x = new | method \(\); \} \} \} 1. The error is when one uses the value assigned within a synchronized section, outside of a synchronized section. if \( x == null \) is outside of synchronized section x = new | method \(\);

Very very specific check for double checked locking.
<div class="source"><pre>

public class Foo \{
  Object baz;
  Object bar \(\) \{
    if \( baz == null \) \{ //baz may be non-null yet not fully created
      synchronized \( this \)\{
        if \( baz == null \)\{
          baz = new Object \(\);
        \}
      \}
    \}
    return baz;
  \}
\}


            </pre></div>

u:(ReturnFromFinallyBlock) Avoid returning from a finally block - this can discard exceptions.
<div class="source"><pre>

public class Bar \{
 public String foo \(\) \{
  try \{
   throw new Exception \( "My Exception" \);
  \} catch \(Exception e \) \{
   throw e;
  \} finally \{
   return "A. O. K."; // Very bad.
  \}
 \}
\}


            </pre></div>

u:(return from finally block) Avoid returning from a finally block - this can discard exceptions.
<div class="source"><pre>

public class Bar \{
 public String foo \(\) \{
  try \{
   throw new Exception \( "My Exception" \);
  \} catch \(Exception e \) \{
   throw e;
  \} finally \{
   return "A. O. K."; // Very bad.
  \}
 \}
\}


            </pre></div>

u: (UnconditionalIfStatement) Do not use "if" statements that are always true or always false.
<div class="source"><pre>

public class Foo \{
 public void close \(\) \{
  if \(true \) \{
       // ...
   \}
 \}
\}


            </pre></div>

u: (unconditional if statement) Do not use "if" statements that are always true or always false.
<div class="source"><pre>

public class Foo \{
 public void close \(\) \{
  if \(true \) \{
       // ...
   \}
 \}
\}


            </pre></div>

u: (BooleanInstantiation) Avoid instantiating Boolean objects; you can reference Boolean.TRUE, Boolean.FALSE, or call Boolean.valueOf \(\) instead.
<div class="source"><pre>

public class Foo \{
 Boolean bar = new Boolean \("true"\); // just do a Boolean bar = Boolean.TRUE;
 Boolean buz = Boolean.valueOf \(false \); // just do a Boolean buz = Boolean.FALSE;
\}


            </pre></div>

u: (boolean instantiation) Avoid instantiating Boolean objects; you can reference Boolean.TRUE, Boolean.FALSE, or call Boolean.valueOf \(\) instead.
<div class="source"><pre>

public class Foo \{
 Boolean bar = new Boolean \("true"\); // just do a Boolean bar = Boolean.TRUE;
 Boolean buz = Boolean.valueOf \(false \); // just do a Boolean buz = Boolean.FALSE;
\}


            </pre></div>

u: (CollapsibleIfStatements) Sometimes two 'if' statements can be consolidated by separating their conditions with a boolean short-circuit operator.
<div class="source"><pre>

public class Foo \{
 void bar \(\) \{
  if \(x \) \{
   if \(y \) \{
    // do stuff
   \}
  \}
 \}
\}


            </pre></div>

u: (collapsible if statements) Sometimes two 'if' statements can be consolidated by separating their conditions with a boolean short-circuit operator.
<div class="source"><pre>

public class Foo \{
 void bar \(\) \{
  if \(x \) \{
   if \(y \) \{
    // do stuff
   \}
  \}
 \}
\}


            </pre></div>

u: (ClassCastExceptionWithToArray) if you need to get an array of a class from your Collection, you should pass an array of the desidered class as the parameter of the toArray method. Otherwise you will get a ClassCastException.
<div class="source"><pre>

import java.util.ArrayList;
import java.util.Collection;

public class Test \{

    public static void main \(String\[\] args\) \{
        Collection c=new ArrayList \(\);
        Integer obj=new Integer \(1 \);
        c.add \(obj \);

        // this would trigger the rule \( and throw a ClassCastException
if executed \)
        Integer\[\] a= \(Integer \[\]\)c.toArray \(\);

        // this wouldn't trigger the rule
        Integer\[\] b= \(Integer \[\]\)c.toArray \(new Integer\[c.size \(\)\]\);
    \}
\}


            </pre></div>

u: (class cast exception with to array) if you need to get an array of a class from your Collection, you should pass an array of the desidered class as the parameter of the toArray method. Otherwise you will get a ClassCastException.
<div class="source"><pre>

import java.util.ArrayList;
import java.util.Collection;

public class Test \{

    public static void main \(String\[\] args\) \{
        Collection c=new ArrayList \(\);
        Integer obj=new Integer \(1 \);
        c.add \(obj \);

        // this would trigger the rule \( and throw a ClassCastException
if executed \)
        Integer\[\] a= \(Integer \[\]\)c.toArray \(\);

        // this wouldn't trigger the rule
        Integer\[\] b= \(Integer \[\]\)c.toArray \(new Integer\[c.size \(\)\]\);
    \}
\}


            </pre></div>

u: (MisplacedNullCheck) The null check here is misplaced. if the variable is null you'll get a NullPointerException. Either the check is useless \(the variable will never be "null"\) or it's incorrect.
<div class="source"><pre>

public class Foo \{
 void bar \(\) \{
  if \(a.equals\(baz\) &amp;&amp; a != null \) \{\}
 \}
\}


            </pre></div>

u: (misplaced null check) The null check here is misplaced. if the variable is null you'll get a NullPointerException. Either the check is useless \(the variable will never be "null"\) or it's incorrect.
<div class="source"><pre>

public class Foo \{
 void bar \(\) \{
  if \(a.equals\(baz\) &amp;&amp; a != null \) \{\}
 \}
\}


            </pre></div>

u: (BrokenNullCheck) The null check is broken since it will throw a NullPointerException itself. It is likely that you used || instead of && or vice versa.
<div class="source"><pre>

class Foo \{
 String bar \(String string \) \{
  // should be &amp;&amp;
  if \(string!=null || !string.equals\(""\)\)
    return string;
  // should be ||
  if \(string==null &amp;&amp; string.equals\(""\)\)
    return string;
 \}
\}


            </pre></div>

u: (broken null check) The null check is broken since it will throw a NullPointerException itself. It is likely that you used || instead of && or vice versa.
<div class="source"><pre>

class Foo \{
 String bar \(String string \) \{
  // should be &amp;&amp;
  if \(string!=null || !string.equals\(""\)\)
    return string;
  // should be ||
  if \(string==null &amp;&amp; string.equals\(""\)\)
    return string;
 \}
\}


            </pre></div>

u: (AvoidMultipleUnaryOperators) Using multiple unary operators may be a bug, and/or is confusing. Check the usage is not a bug, or consider simplifying the expression.
<div class="source"><pre>

            // These are typo bugs, or at best needlessly complex and confusing:
            int i = - -1;
            int j = + - +1;
            int z = \~\~2;
            boolean b = !!true;
            boolean c = !!!true;

            // These are better:
            int i = 1;
            int j = -1;
            int z = 2;
            boolean b = true;
            boolean c = false;

            // And these just make your brain hurt:
            int i = \~-2;
            int j = -\~7;


            </pre></div>

u: (avoid multiple unary operators) Using multiple unary operators may be a bug, and/or is confusing. Check the usage is not a bug, or consider simplifying the expression.
<div class="source"><pre>

            // These are typo bugs, or at best needlessly complex and confusing:
            int i = - -1;
            int j = + - +1;
            int z = \~\~2;
            boolean b = !!true;
            boolean c = !!!true;

            // These are better:
            int i = 1;
            int j = -1;
            int z = 2;
            boolean b = true;
            boolean c = false;

            // And these just make your brain hurt:
            int i = \~-2;
            int j = -~7;


            </pre></div>

u: (AvoidBranchingStatementAsLastInLoop) Using a branching statement as the last part of a loop may be a bug, and/or is confusing. Ensure that the usage is not a bug, or consider using another approach.
<div class="source"><pre>
  // unusual use of branching statement in a loop
for \(int i = 0; i &lt; 10; i++ \) \{
	if \(i*i &lt;= 25 \) \{
		continue;
	\}
	break;
\}

  // this makes more sense...
for \(int i = 0; i &lt; 10; i++ \) \{
	if \(i*i &gt; 25 \) \{
		break;
	\}
\}

        </pre></div>

u: (avoid branching statement as last in loop) Using a branching statement as the last part of a loop may be a bug, and/or is confusing. Ensure that the usage is not a bug, or consider using another approach.
<div class="source"><pre>
  // unusual use of branching statement in a loop
for \(int i = 0; i &lt; 10; i++ \) \{
	if \(i*i &lt;= 25 \) \{
		continue;
	\}
	break;
\}

  // this makes more sense...
for \(int i = 0; i &lt; 10; i++ \) \{
	if \(i*i &gt; 25 \) \{
		break;
	\}
\}

        </pre></div>

u: (DontCallThreadRun) Explicitly calling Thread.run \(\) method will execute in the caller's thread of control. Instead, call Thread.start \(\) for the intended behavior.
<div class="source">
<pre>
Thread t = new Thread \(\);
t.run \(\);            // use t.start \(\) instead
new Thread \(\).run \(\); // same violation

      </pre></div>

u: (do not call thread run) Explicitly calling Thread.run \(\) method will execute in the caller's thread of control. Instead, call Thread.start \(\) for the intended behavior.
<div class="source">
<pre>
Thread t = new Thread \(\);
t.run \(\);            // use t.start \(\) instead
new Thread \(\).run \(\); // same violation

      </pre></div>

u: (DontUseFloatTypeForLoopIndices) Dont use floating point for loop indices. If you must use floating point, use double unless youre certain that float provides enough precision and you have a compelling performance need (space or time).
<div class="source">
<pre>
public class Count \{
  public static void main \(String\[\] args\) \{
    final int START = 2000000000;
    int count = 0;
    for \(float f = START; f &lt; START + 50; f++ \)
      count++;
      //Prints 0 because \( float \) START == \( float \) \( START + 50 \).
      System.out.println \( count \);
      //The termination test misbehaves due to floating point granularity.
    \}
\}

    </pre></div>

u: (do not use float type for loop indices) Dont use floating point for loop indices. If you must use floating point, use double unless youre certain that float provides enough precision and you have a compelling performance need (space or time).
<div class="source">
<pre>
public class Count \{
  public static void main \(String\[\] args\) \{
    final int START = 2000000000;
    int count = 0;
    for \(float f = START; f &lt; START + 50; f++ \)
      count++;
      //Prints 0 because \( float \) START == \( float \) \( START + 50 \).
      System.out.println \( count \);
      //The termination test misbehaves due to floating point granularity.
    \}
\}

    </pre></div>

u: (SwitchStmtsShouldHaveDefault)  Switch statements should have a default label.
<div class="source"><pre>

public class Foo \{
 public void bar \(\) \{
  int x = 2;
  switch \(x \) \{
   case 2: int j = 8;
  \}
 \}
\}


            </pre></div>

u: (switch stmts should have default)  Switch statements should have a default label.
<div class="source"><pre>

public class Foo \{
 public void bar \(\) \{
  int x = 2;
  switch \(x \) \{
   case 2: int j = 8;
  \}
 \}
\}


            </pre></div>

u: (NonCaseLabelInSwitchStatement) A non-case label \(e.g. a named break/continue label \) was present in a switch statement. This legal, but confusing. It is easy to mix up the case labels and the non-case labels.
<div>
<pre>
public class Foo \{
  void bar \(int a \) \{
   switch \(a \) \{
     case 1:
       // do something
       break;
     mylabel: // this is legal, but confusing!
       break;
     default:
       break;
    \}
  \}
\}

       </pre></div>

u: (NonCaseLabelInSwitchStatement) A non-case label \(e.g. a named break/continue label \) was present in a switch statement. This legal, but confusing. It is easy to mix up the case labels and the non-case labels.
<div>
<pre>
public class Foo \{
  void bar \(int a \) \{
   switch \(a \) \{
     case 1:
       // do something
       break;
     mylabel: // this is legal, but confusing!
       break;
     default:
       break;
    \}
  \}
\}

       </pre></div>

u: (EqualsNull)  Inexperienced programmers sometimes confuse comparison concepts and use equals \(\) to compare to null.
<div class="source"><pre>

class Bar \{
   void foo \(\) \{
       String x = "foo";
       if \(x.equals \(null \) \) \{ // bad!
        doSomething\(\);
       \}
   \}
\}


            </pre></div>

u: (equals null)  Inexperienced programmers sometimes confuse comparison concepts and use equals \(\) to compare to null.
<div class="source"><pre>

class Bar \{
   void foo \(\) \{
       String x = "foo";
       if \(x.equals \(null \) \) \{ // bad!
        doSomething\(\);
       \}
   \}
\}


            </pre></div>

u: (InstantiationToGetClass) Avoid instantiating an object just to call getClass \(\) on it; use the .class public member instead.
<div class="source"><pre>

public class Foo \{
 // Replace this
 Class c = new String \(\).getClass \(\);
 // with this:
 Class c = String.class;
\}


            </pre></div>

u: (instantiation to get class) Avoid instantiating an object just to call getClass \(\) on it; use the .class public member instead.
<div class="source"><pre>

public class Foo \{
 // Replace this
 Class c = new String \(\).getClass \(\);
 // with this:
 Class c = String.class;
\}


            </pre></div>

u: (IdempotentOperations) Avoid idempotent operations - they are have no effect.
<div class="source"><pre>

public class Foo \{
 public void bar \(\) \{
  int x = 2;
  x = x;
 \}
\}


            </pre></div>

u: (idempotent operations) Avoid idempotent operations - they are have no effect.
<div class="source"><pre>

public class Foo \{
 public void bar \(\) \{
  int x = 2;
  x = x;
 \}
\}


            </pre></div>

u: (MissingStaticMethodInNonInstantiatableClass) A class that has private constructors and does not have any static methods or fields cannot be used.
<div class="source"><pre>

/* This class is unusable, since it cannot be
 instantiated \(private constructor \),
 and no static method can be called.
 */
public class Foo \{
 private Foo \(\) \{\}
 void foo \(\) \{\}
\}



            </pre></div>

u: (missing static method in non instantiatable class) A class that has private constructors and does not have any static methods or fields cannot be used.
<div class="source"><pre>

/* This class is unusable, since it cannot be
 instantiated \(private constructor \),
 and no static method can be called.
 */
public class Foo \{
 private Foo \(\) \{\}
 void foo \(\) \{\}
\}



            </pre></div>

u: (SimplifyConditional) No need to check for null before an instanceof; the instanceof keyword returns false when given a null argument.
<div class="source"><pre>

class Foo \{
 void bar \(Object x \) \{
  if \(x != null &amp;&amp; x instanceof Bar \) \{
   // just drop the "x != null" check
  \}
 \}
\}

            </pre></div>

u: (simplify conditional) No need to check for null before an instanceof; the instanceof keyword returns false when given a null argument.
<div class="source"><pre>

class Foo \{
 void bar \(Object x \) \{
  if \(x != null &amp;&amp; x instanceof Bar \) \{
   // just drop the "x != null" check
  \}
 \}
\}

            </pre></div>

u: (SingularField) This field is used in only one method and the first usage is assigning a value to the field. This probably means that the field can be changed to a local variable.

u: (singular field) This field is used in only one method and the first usage is assigning a value to the field. This probably means that the field can be changed to a local variable.

u: (TooFewBranchesForASwitchStatement) Swith are designed complex branches, and allow branches to share treatement. Using a switch for only a few branches is ill advised, as switches are not as easy to understand as if. In this case, it's most likely is a good idea to use a if statement instead, at least to increase code readability.
<div class="source"><pre class="prettyprint"><span class="pln">
</span><span class="com">// With a minimumNumberCaseForASwitch of 3</span><span class="pln">
</span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Foo</span><span class="pln"> </span><span class="pun">\{</span><span class="pln">
    </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> bar</span><span class="pun">\(\)</span><span class="pln"> </span><span class="pun">\{</span><span class="pln">
        </span><span class="kwd">switch</span><span class="pln"> </span><span class="pun">\(</span><span class="pln">condition</span><span class="pun">\)</span><span class="pln"> </span><span class="pun">\{</span><span class="pln">
            </span><span class="kwd">case</span><span class="pln"> ONE</span><span class="pun">:</span><span class="pln">
                instruction</span><span class="pun">;</span><span class="pln">
                </span><span class="kwd">break</span><span class="pun">;</span><span class="pln">
            </span><span class="kwd">default</span><span class="pun">:</span><span class="pln">
                </span><span class="kwd">break</span><span class="pun">;</span><span class="pln"> </span><span class="com">// not enough for a 'switch' stmt, a simple 'if' stmt would have been more appropriate</span><span class="pln">
        </span><span class="pun">\}</span><span class="pln">
    </span><span class="pun">\}</span><span class="pln">
</span><span class="pun">\}</span><span class="pln">

        </span></pre></div>

u: (too few branches for a switch statement) Swith are designed complex branches, and allow branches to share treatement. Using a switch for only a few branches is ill advised, as switches are not as easy to understand as if. In this case, it's most likely is a good idea to use a if statement instead, at least to increase code readability.
<div class="source"><pre class="prettyprint"><span class="pln">
</span><span class="com">// With a minimumNumberCaseForASwitch of 3</span><span class="pln">
</span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Foo</span><span class="pln"> </span><span class="pun">\{</span><span class="pln">
    </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> bar</span><span class="pun">\(\)</span><span class="pln"> </span><span class="pun">\{</span><span class="pln">
        </span><span class="kwd">switch</span><span class="pln"> </span><span class="pun">\(</span><span class="pln">condition</span><span class="pun">\)</span><span class="pln"> </span><span class="pun">\{</span><span class="pln">
            </span><span class="kwd">case</span><span class="pln"> ONE</span><span class="pun">:</span><span class="pln">
                instruction</span><span class="pun">;</span><span class="pln">
                </span><span class="kwd">break</span><span class="pun">;</span><span class="pln">
            </span><span class="kwd">default</span><span class="pun">:</span><span class="pln">
                </span><span class="kwd">break</span><span class="pun">;</span><span class="pln"> </span><span class="com">// not enough for a 'switch' stmt, a simple 'if' stmt would have been more appropriate</span><span class="pln">
        </span><span class="pun">\}</span><span class="pln">
    </span><span class="pun">\}</span><span class="pln">
</span><span class="pun">\}</span><span class="pln">

        </span></pre></div>

u: (LogicInversion) Use opposite operator instead of negating the whole expression with a logic complement operator.
<div class="source"><pre class="prettyprint"><span class="pln">
</span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">boolean</span><span class="pln"> bar</span><span class="pun">\(</span><span class="kwd">int</span><span class="pln"> a</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> b</span><span class="pun">)</span><span class="pln"> </span><span class="pun">\{</span><span class="pln">

	</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">\(!\(</span><span class="pln">a </span><span class="pun">==</span><span class="pln"> b</span><span class="pun">\)\)</span><span class="pln"> </span><span class="com">// use !=</span><span class="pln">
         </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><span class="pln">

	</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">\(!\(</span><span class="pln">a </span><span class="pun">&lt;</span><span class="pln"> b</span><span class="pun">\)\)</span><span class="pln"> </span><span class="com">// use &gt;=</span><span class="pln">
         </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><span class="pln">

	</span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">;</span><span class="pln">
</span><span class="pun">\}</span><span class="pln">

    </span></pre></div>

u: (logic inversion) Use opposite operator instead of negating the whole expression with a logic complement operator.
<div class="source"><pre class="prettyprint"><span class="pln">
</span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">boolean</span><span class="pln"> bar</span><span class="pun">\(</span><span class="kwd">int</span><span class="pln"> a</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> b</span><span class="pun">)</span><span class="pln"> </span><span class="pun">\{</span><span class="pln">

	</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">\(!\(</span><span class="pln">a </span><span class="pun">==</span><span class="pln"> b</span><span class="pun">\)\)</span><span class="pln"> </span><span class="com">// use !=</span><span class="pln">
         </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><span class="pln">

	</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">\(!\(</span><span class="pln">a </span><span class="pun">&lt;</span><span class="pln"> b</span><span class="pun">\)\)</span><span class="pln"> </span><span class="com">// use &gt;=</span><span class="pln">
         </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><span class="pln">

	</span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">;</span><span class="pln">
</span><span class="pun">\}</span><span class="pln">

    </span></pre></div>

u: (EmptyCatchBlock) Empty Catch Block finds instances where an exception is caught, but nothing is done. In most circumstances, this swallows an exception which should either be acted on or reported.
<div class="source"><pre>

public void doSomething \(\) \{
  try \{
    FileInputStream fis = new FileInputStream \("/tmp/bugger"\);
  \} catch \(IOException ioe \) \{
      // not good
  \}
\}


            </pre></div>

u: (empty catch block) Empty Catch Block finds instances where an exception is caught, but nothing is done. In most circumstances, this swallows an exception which should either be acted on or reported.
<div class="source"><pre>

public void doSomething \(\) \{
  try \{
    FileInputStream fis = new FileInputStream \("/tmp/bugger"\);
  \} catch \(IOException ioe \) \{
      // not good
  \}
\}


            </pre></div>

u: (EmptyIfStmt) Empty If Statement finds instances where a condition is checked but nothing is done about it.
<div class="source"><pre>

public class Foo \{
 void bar \(int x \) \{
  if \(x == 0 \) \{
   // empty!
  \}
 \}
\}


            </pre></div>

u: (empty if stmt) Empty If Statement finds instances where a condition is checked but nothing is done about it.
<div class="source"><pre>

public class Foo \{
 void bar \(int x \) \{
  if \(x == 0 \) \{
   // empty!
  \}
 \}
\}


            </pre></div>

u: (EmptyWhileStmt) Empty While Statement finds all instances where a while statement does nothing. If it is a timing loop, then you should use Thread.sleep \(\) for it; if it's a while loop that does a lot in the exit expression, rewrite it to make it clearer.
<div class="source"><pre>

public class Foo \{
 void bar \(int a, int b \) \{
  while \(a == b \) \{
   // empty!
  \}
 \}
\}


            </pre></div>

u: (empty while stmt) Empty While Statement finds all instances where a while statement does nothing. If it is a timing loop, then you should use Thread.sleep \(\) for it; if it's a while loop that does a lot in the exit expression, rewrite it to make it clearer.
<div class="source"><pre>

public class Foo \{
 void bar \(int a, int b \) \{
  while \(a == b \) \{
   // empty!
  \}
 \}
\}


            </pre></div>

u: (EmptyTryBlock) Avoid empty try blocks - what's the point?
<div class="source"><pre>

public class Foo \{
 public void bar \(\) \{
  try \{
  \} catch \(Exception e \) \{
    e.printStackTrace \(\);
  \}
 \}
\}


            </pre></div>

u: (empty try block) Avoid empty try blocks - what's the point?
<div class="source"><pre>

public class Foo \{
 public void bar \(\) \{
  try \{
  \} catch \(Exception e \) \{
    e.printStackTrace \(\);
  \}
 \}
\}


            </pre></div>

u: (EmptyFinallyBlock) Avoid empty finally blocks - these can be deleted.
<div class="source"><pre>

public class Foo \{
 public void bar \(\) \{
  try \{
    int x=2;
   \} finally \{
    // empty!
   \}
 \}
\}


            </pre></div>

u: (empty finally block) Avoid empty finally blocks - these can be deleted.
<div class="source"><pre>

public class Foo \{
 public void bar \(\) \{
  try \{
    int x=2;
   \} finally \{
    // empty!
   \}
 \}
\}


            </pre></div>

u: (EmptySwitchStatements) Avoid empty switch statements.
<div class="source"><pre>

public class Foo \{
 public void bar \(\) \{
  int x = 2;
  switch \(x \) \{
   // once there was code here
   // but it's been commented out or something
  \}
 \}
\}

            </pre></div>

u: (empty switch statements) Avoid empty switch statements.
<div class="source"><pre>

public class Foo \{
 public void bar \(\) \{
  int x = 2;
  switch \(x \) \{
   // once there was code here
   // but it's been commented out or something
  \}
 \}
\}

            </pre></div>

u: (EmptySynchronizedBlock) Avoid empty synchronized blocks - they're useless.
<div class="source"><pre>

public class Foo \{
 public void bar \(\) \{
  synchronized \(this \) \{
   // empty!
  \}
 \}
\}


            </pre></div>

u: (empty synchronized block) Avoid empty synchronized blocks - they're useless.
<div class="source"><pre>

public class Foo \{
 public void bar \(\) \{
  synchronized \(this \) \{
   // empty!
  \}
 \}
\}


            </pre></div>

u: (EmptyInitializer) An empty initializer was found.
<div class="source">
<pre>
public class Foo \{

   static \{\} // Why ?

   \{\} // Again, why ?

\}

    </pre></div>

u: (empty initializer) An empty initializer was found.
<div class="source">
<pre>
public class Foo \{

   static \{\} // Why ?

   \{\} // Again, why ?

\}

    </pre></div>

u: (EmptyStatementBlock) Empty block statements serve no purpose and should be removed.
<div class="source"><pre>
public class Foo \{

   private int _bar;

   public void setBar \(int bar \) \{
      \{ _bar = bar; \} // Why not?
      \{\} // But remove this.
   \}

\}

    </pre></div>

u: (empty statement block) Empty block statements serve no purpose and should be removed.
<div class="source"><pre>
public class Foo \{

   private int _bar;

   public void setBar \(int bar \) \{
      \{ _bar = bar; \} // Why not?
      \{\} // But remove this.
   \}

\}

    </pre></div>

u: (EmptyStaticInitializer) An empty static initializer serve no purpose and should be removed.
<div class="source"><pre>

public class Foo \{
 static \{
  // empty
 \}
 \}


            </pre></div>

u: (empty static initializer) An empty static initializer serve no purpose and should be removed.
<div class="source"><pre>

public class Foo \{
 static \{
  // empty
 \}
 \}


            </pre></div>

u: (DuplicateImports) Avoid duplicate import statements.
Example:
import java.lang.String;
import java.lang.*;
public class Foo \{\}

u: (duplicate imports) Avoid duplicate import statements.
Example:
import java.lang.String;
import java.lang.*;
public class Foo \{\}

u: (DontImportJavaLang) Avoid importing anything from the package 'java.lang'. These classes are automatically imported \(JLS 7.5.3 \).

Example:



// this is bad
import java.lang.String;
public class Foo \{\}

// --- in another source code file...

// this is bad
import java.lang.*;

public class Foo \{\}

u: (do not import "java.lang") Avoid importing anything from the package 'java.lang'. These classes are automatically imported \(JLS 7.5.3 \).

Example:



// this is bad
import java.lang.String;
public class Foo \{\}

// --- in another source code file...

// this is bad
import java.lang.*;

public class Foo \{\}

u: (UnusedImports) Avoid unused import statements.

Example:



// this is bad
import java.io.File;
public class Foo \{\}

u: (unused imports) Avoid unused import statements.

Example:



// this is bad
import java.io.File;
public class Foo \{\}

u: (ImportFromSamePackage) No need to import a type that lives in the same package.

Example:

 package foo;
 import foo.Buz; // no need for this
 import foo.*; // or this
 public class Bar\{\}

u: (import from same package) No need to import a type that lives in the same package.

Example:

 package foo;
 import foo.Buz; // no need for this
 import foo.*; // or this
 public class Bar\{\}

u: (SuspiciousHashcodeMethodName) The method name and return type are suspiciously close to hashCode \(\), which may mean you are intending to override the hashCode \(\) method.

<p>Example:</p>

    <div class="source"><pre>


public class Foo \{
 public int hashcode \(\) \{
 // oops, this probably was supposed to be hashCode
 \}
\}


            </pre></div>

u: (suspicious hashcode method name) The method name and return type are suspiciously close to hashCode \(\), which may mean you are intending to override the hashCode \(\) method.

<p>Example:</p>

    <div class="source"><pre>


public class Foo \{
 public int hashcode \(\) \{
 // oops, this probably was supposed to be hashCode
 \}
\}


            </pre></div>

u: (AvoidThrowingNullPointerException) Avoid throwing a NullPointerException - it's confusing because most people will assume that the virtual machine threw it. Consider using an IllegalArgumentException instead; this will be clearly seen as a programmer-initiated exception.
<p>Example:</p>
<div class="source"><pre>
public class Foo \{
 void bar \(\) \{
  throw new NullPointerException \(\);
 \}
\}


            </pre></div>

u: (avoid throwing null pointer exception) Avoid throwing a NullPointerException - it's confusing because most people will assume that the virtual machine threw it. Consider using an IllegalArgumentException instead; this will be clearly seen as a programmer-initiated exception.
<p>Example:</p>
<div class="source"><pre>
public class Foo \{
 void bar \(\) \{
  throw new NullPointerException \(\);
 \}
\}


            </pre></div>

u: (AvoidRethrowingException) Catch blocks that merely rethrow a caught exception only add to code size and runtime complexity.
<div class="source"><pre>
  public class Foo \{
   void bar \(\) \{
    try \{
    // do something
    \}  catch \(SomeException se \) \{
       throw se;
    \}
   \}
  \}


            </pre></div>

u: (avoid rethrowing exception) Catch blocks that merely rethrow a caught exception only add to code size and runtime complexity.
<div class="source"><pre>
  public class Foo \{
   void bar \(\) \{
    try \{
    // do something
    \}  catch \(SomeException se \) \{
       throw se;
    \}
   \}
  \}


            </pre></div>

u: (DoNotExtendJavaLangError) Errors are system exceptions. Do not extend them.

<div class="source"><pre>
        public class Foo extends Error \{ \}

            </pre></div>

u: (do not extend "java.lang.error") Errors are system exceptions. Do not extend them.

<div class="source"><pre>
        public class Foo extends Error \{ \}

            </pre></div>

u: (DoNotThrowExceptionInFinally) Throwing exception in a finally block is confusing. It may mask exception or a defect of the code, it also render code cleanup uninstable. Note: This is a PMD implementation of the Lint4j rule "A throw in a finally block"

<div class="source"><pre>

				public class Foo
				\{
					public void bar \(\)
					\{
						try \{
							// Here do some stuff
						\}
						catch \( Exception e \) \{
							// Handling the issue
						\}
						finally
						\{
							// is this really a good idea ?
							throw new Exception \(\);
						\}
					\}
				\}


            </pre></div>

u: (do not throw exception in finally) Throwing exception in a finally block is confusing. It may mask exception or a defect of the code, it also render code cleanup uninstable. Note: This is a PMD implementation of the Lint4j rule "A throw in a finally block"

<div class="source"><pre>

	public class Foo
	\{
		public void bar \(\)
		\{
			try \{
				// Here do some stuff
			\}
			catch \( Exception e \) \{
				// Handling the issue
			\}
			finally
			\{
				// is this really a good idea ?
				throw new Exception \(\);
			\}
		\}
	\}


</pre></div>

u: (avoid throwing new instance of same exception) Catch blocks that merely rethrow a caught exception wrapped inside a new instance of the same type only add to code size and runtime complexity.

<div class="source"><pre>
    public class Foo \{
     void bar \(\) \{
      try \{
       // do something
      \}  catch \(SomeException se \) \{
         // harmless comment
           throw new SomeException \(se \);
      \}
     \}
    \}


            </pre></div>

u: (AvoidThrowingNewInstanceOfSameException) Catch blocks that merely rethrow a caught exception wrapped inside a new instance of the same type only add to code size and runtime complexity.

<div class="source"><pre>
    public class Foo \{
     void bar \(\) \{
      try \{
       // do something
      \}  catch \(SomeException se \) \{
         // harmless comment
           throw new SomeException \(se \);
      \}
     \}
    \}


            </pre></div>

u: (StringInstantiation) Avoid instantiating String objects; this is usually unnecessary.

<div class="source"><pre>

public class Foo \{
 private String bar = new String \("bar"\); // just do a String bar = "bar";
\}


            </pre></div>

u: (string instantiation) Avoid instantiating String objects; this is usually unnecessary.

<div class="source"><pre>

public class Foo \{
 private String bar = new String \("bar"\); // just do a String bar = "bar";
\}


            </pre></div>

u: (UnnecessaryCaseChange) Using equalsIgnoreCase \(\) is faster than using toUpperCase/toLowerCase \(\).equals \(\)

<div class="source"><pre>

 public class Foo \{
  public boolean bar \(String buz \) \{
    // should be buz.equalsIgnoreCase\("baz"\)
    return buz.toUpperCase\(\).equals\("baz"\);
    // another unnecessary toUpperCase\(\)
    // return buz.toUpperCase\(\).equalsIgnoreCase\("baz"\);
  \}
 \}


            </pre></div>

u: (unnecessary case change) Using equalsIgnoreCase \(\) is faster than using toUpperCase/toLowerCase \(\).equals \(\)

<div class="source"><pre>

 public class Foo \{
  public boolean bar \(String buz \) \{
    // should be buz.equalsIgnoreCase\("baz"\)
    return buz.toUpperCase\(\).equals\("baz"\);
    // another unnecessary toUpperCase\(\)
    // return buz.toUpperCase\(\).equalsIgnoreCase\("baz"\);
  \}
 \}


            </pre></div>

u: (UnnecessaryConversionTemporary) Avoid the use temporary objects when converting primitives to Strings. Use the static conversion methods on the wrapper classes instead.
<div class="source"><pre class="prettyprint"><span class="pln">
</span><span class="kwd">public</span><span class="pln"> </span><span class="typ">String</span><span class="pln"> convert</span><span class="pun">\(</span><span class="kwd">int</span><span class="pln"> x</span><span class="pun">\)</span><span class="pln"> </span><span class="pun">\{</span><span class="pln">
	</span><span class="typ">String</span><span class="pln"> foo </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Integer</span><span class="pun">\(</span><span class="pln">x</span><span class="pun">\).</span><span class="pln">toString</span><span class="pun">\(\);</span><span class="pln">	</span><span class="com">// this wastes an object</span><span class="pln">

	</span><span class="kwd">return</span><span class="pln"> </span><span class="typ">Integer</span><span class="pun">.</span><span class="pln">toString</span><span class="pun">\(</span><span class="pln">x</span><span class="pun">\);</span><span class="pln">				</span><span class="com">// preferred approach</span><span class="pln">
</span><span class="pun">\}</span><span class="pln">

      </span></pre></div>

u: (unnecessary conversion temporary) Avoid the use temporary objects when converting primitives to Strings. Use the static conversion methods on the wrapper classes instead.
<div class="source"><pre class="prettyprint"><span class="pln">
</span><span class="kwd">public</span><span class="pln"> </span><span class="typ">String</span><span class="pln"> convert</span><span class="pun">\(</span><span class="kwd">int</span><span class="pln"> x</span><span class="pun">\)</span><span class="pln"> </span><span class="pun">\{</span><span class="pln">
</span><span class="typ">String</span><span class="pln"> foo </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Integer</span><span class="pun">\(</span><span class="pln">x</span><span class="pun">\).</span><span class="pln">toString</span><span class="pun">\(\);</span><span class="pln">	</span><span class="com">// this wastes an object</span><span class="pln">

</span><span class="kwd">return</span><span class="pln"> </span><span class="typ">Integer</span><span class="pun">.</span><span class="pln">toString</span><span class="pun">\(</span><span class="pln">x</span><span class="pun">\);</span><span class="pln">				</span><span class="com">// preferred approach</span><span class="pln">
</span><span class="pun">\}</span><span class="pln">

</span></pre></div>

u: (UnnecessaryReturn) Avoid the use of unnecessary return statements.

<div class="source"><pre class="prettyprint"><span class="pln">
</span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Foo</span><span class="pln"> </span><span class="pun">\{</span><span class="pln">
  </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> bar</span><span class="pun">\(\)</span><span class="pln"> </span><span class="pun">\{</span><span class="pln">
    </span><span class="kwd">int</span><span class="pln"> x </span><span class="pun">=</span><span class="pln"> </span><span class="lit">42</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">return</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">\}</span><span class="pln">
</span><span class="pun">\}</span><span class="pln">

      </span></pre></div>

u: (unnecessary return) Avoid the use of unnecessary return statements.

<div class="source"><pre class="prettyprint"><span class="pln">
</span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Foo</span><span class="pln"> </span><span class="pun">\{</span><span class="pln">
</span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> bar</span><span class="pun">\(\)</span><span class="pln"> </span><span class="pun">\{</span><span class="pln">
</span><span class="kwd">int</span><span class="pln"> x </span><span class="pun">=</span><span class="pln"> </span><span class="lit">42</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">return</span><span class="pun">;</span><span class="pln">
</span><span class="pun">\}</span><span class="pln">
</span><span class="pun">\}</span><span class="pln">

</span></pre></div>

u: (UnnecessaryFinalModifier) When a class has the final modifier, all the methods are automatically final and do not need to be tagged as such.

<div class="source"><pre class="prettyprint"><span class="pln">
</span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">final</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Foo</span><span class="pln"> </span><span class="pun">\{</span><span class="pln">
    </span><span class="com">// This final modifier is not necessary, since the class is final</span><span class="pln">
    </span><span class="com">// and thus, all methods are final</span><span class="pln">
    </span><span class="kwd">private</span><span class="pln"> </span><span class="kwd">final</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> foo</span><span class="pun">\(\)</span><span class="pln"> </span><span class="pun">\{</span><span class="pln">
    </span><span class="pun">\}</span><span class="pln">
</span><span class="pun">\}</span><span class="pln">


      </span></pre></div>

u: (unnecessary final modifier) When a class has the final modifier, all the methods are automatically final and do not need to be tagged as such.

<div class="source"><pre class="prettyprint"><span class="pln">
</span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">final</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Foo</span><span class="pln"> </span><span class="pun">\{</span><span class="pln">
    </span><span class="com">// This final modifier is not necessary, since the class is final</span><span class="pln">
    </span><span class="com">// and thus, all methods are final</span><span class="pln">
    </span><span class="kwd">private</span><span class="pln"> </span><span class="kwd">final</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> foo</span><span class="pun">\(\)</span><span class="pln"> </span><span class="pun">\{</span><span class="pln">
    </span><span class="pun">\}</span><span class="pln">
</span><span class="pun">\}</span><span class="pln">


      </span></pre></div>

u: (UselessOverridingMethod) The overriding method merely calls the same method defined in a superclass.

<div class="source"><pre class="prettyprint"><span class="kwd">public</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> foo</span><span class="pun">\(</span><span class="typ">String</span><span class="pln"> bar</span><span class="pun">\)</span><span class="pln"> </span><span class="pun">\{</span><span class="pln">
  </span><span class="kwd">super</span><span class="pun">.</span><span class="pln">foo</span><span class="pun">\(</span><span class="pln">bar</span><span class="pun">\);</span><span class="pln">      </span><span class="com">// why bother overriding?</span><span class="pln">
</span><span class="pun">\}</span><span class="pln">

</span><span class="kwd">public</span><span class="pln"> </span><span class="typ">String</span><span class="pln"> foo</span><span class="pun">\(\)</span><span class="pln"> </span><span class="pun">\{</span><span class="pln">
	</span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">super</span><span class="pun">.</span><span class="pln">foo</span><span class="pun">\(\);</span><span class="pln">  </span><span class="com">// why bother overriding?</span><span class="pln">
</span><span class="pun">\}</span><span class="pln">

</span><span class="lit">@Id</span><span class="pln">
</span><span class="kwd">public</span><span class="pln"> </span><span class="typ">Long</span><span class="pln"> getId</span><span class="pun">\(\)</span><span class="pln"> </span><span class="pun">\{</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">super</span><span class="pun">.</span><span class="pln">getId</span><span class="pun">\(\);</span><span class="pln">  </span><span class="com">// OK if 'ignoreAnnotations' is false, which is the default behavior</span><span class="pln">
</span><span class="pun">\}</span><span class="pln">
        </span></pre></div>

u: (useless overriding method) The overriding method merely calls the same method defined in a superclass.

<div class="source"><pre class="prettyprint"><span class="kwd">public</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> foo</span><span class="pun">\(</span><span class="typ">String</span><span class="pln"> bar</span><span class="pun">\)</span><span class="pln"> </span><span class="pun">\{</span><span class="pln">
  </span><span class="kwd">super</span><span class="pun">.</span><span class="pln">foo</span><span class="pun">\(</span><span class="pln">bar</span><span class="pun">\);</span><span class="pln">      </span><span class="com">// why bother overriding?</span><span class="pln">
</span><span class="pun">\}</span><span class="pln">

</span><span class="kwd">public</span><span class="pln"> </span><span class="typ">String</span><span class="pln"> foo</span><span class="pun">\(\)</span><span class="pln"> </span><span class="pun">\{</span><span class="pln">
	</span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">super</span><span class="pun">.</span><span class="pln">foo</span><span class="pun">\(\);</span><span class="pln">  </span><span class="com">// why bother overriding?</span><span class="pln">
</span><span class="pun">\}</span><span class="pln">

</span><span class="lit">@Id</span><span class="pln">
</span><span class="kwd">public</span><span class="pln"> </span><span class="typ">Long</span><span class="pln"> getId</span><span class="pun">\(\)</span><span class="pln"> </span><span class="pun">\{</span><span class="pln">
  </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">super</span><span class="pun">.</span><span class="pln">getId</span><span class="pun">\(\);</span><span class="pln">  </span><span class="com">// OK if 'ignoreAnnotations' is false, which is the default behavior</span><span class="pln">
</span><span class="pun">\}</span><span class="pln">
        </span></pre></div>

u: (UselessOperationOnImmutable) An operation on an Immutable object \(String, BigDecimal or BigInteger \) won't change the object itself since the result of the operation is a new object. Therefore, ignoring the operation result is an error.

<div class="source"><pre class="prettyprint"><span class="pln">
</span><span class="kwd">import</span><span class="pln"> java</span><span class="pun">.</span><span class="pln">math</span><span class="pun">.*;</span><span class="pln">

</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Test</span><span class="pln"> </span><span class="pun">\{</span><span class="pln">
  </span><span class="kwd">void</span><span class="pln"> method1</span><span class="pun">\(\)</span><span class="pln"> </span><span class="pun">\{</span><span class="pln">
    </span><span class="typ">BigDecimal</span><span class="pln"> bd</span><span class="pun">=</span><span class="kwd">new</span><span class="pln"> </span><span class="typ">BigDecimal</span><span class="pun">\(</span><span class="lit">10</span><span class="pun">\);</span><span class="pln">
    bd</span><span class="pun">.</span><span class="pln">add</span><span class="pun">\(</span><span class="kwd">new</span><span class="pln"> </span><span class="typ">BigDecimal</span><span class="pun">\(</span><span class="lit">5</span><span class="pun">\)\);</span><span class="pln"> 		</span><span class="com">// this will trigger the rule</span><span class="pln">
  </span><span class="pun">\}</span><span class="pln">
  </span><span class="kwd">void</span><span class="pln"> method2</span><span class="pun">\(\)</span><span class="pln"> </span><span class="pun">\{</span><span class="pln">
    </span><span class="typ">BigDecimal</span><span class="pln"> bd</span><span class="pun">=</span><span class="kwd">new</span><span class="pln"> </span><span class="typ">BigDecimal</span><span class="pun">\(</span><span class="lit">10</span><span class="pun">\);</span><span class="pln">
    bd </span><span class="pun">=</span><span class="pln"> bd</span><span class="pun">.</span><span class="pln">add</span><span class="pun">\(</span><span class="kwd">new</span><span class="pln"> </span><span class="typ">BigDecimal</span><span class="pun">\(</span><span class="lit">5</span><span class="pun">\)\);</span><span class="pln"> </span><span class="com">// this won't trigger the rule</span><span class="pln">
  </span><span class="pun">\}</span><span class="pln">
</span><span class="pun">\}</span><span class="pln">

      </span></pre></div>

u: (useless operation on immutable) An operation on an Immutable object \(String, BigDecimal or BigInteger \) won't change the object itself since the result of the operation is a new object. Therefore, ignoring the operation result is an error.

<div class="source"><pre class="prettyprint"><span class="pln">
</span><span class="kwd">import</span><span class="pln"> java</span><span class="pun">.</span><span class="pln">math</span><span class="pun">.*;</span><span class="pln">

</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Test</span><span class="pln"> </span><span class="pun">\{</span><span class="pln">
  </span><span class="kwd">void</span><span class="pln"> method1</span><span class="pun">\(\)</span><span class="pln"> </span><span class="pun">\{</span><span class="pln">
    </span><span class="typ">BigDecimal</span><span class="pln"> bd</span><span class="pun">=</span><span class="kwd">new</span><span class="pln"> </span><span class="typ">BigDecimal</span><span class="pun">\(</span><span class="lit">10</span><span class="pun">\);</span><span class="pln">
    bd</span><span class="pun">.</span><span class="pln">add</span><span class="pun">\(</span><span class="kwd">new</span><span class="pln"> </span><span class="typ">BigDecimal</span><span class="pun">\(</span><span class="lit">5</span><span class="pun">\)\);</span><span class="pln"> 		</span><span class="com">// this will trigger the rule</span><span class="pln">
  </span><span class="pun">\}</span><span class="pln">
  </span><span class="kwd">void</span><span class="pln"> method2</span><span class="pun">\(\)</span><span class="pln"> </span><span class="pun">\{</span><span class="pln">
    </span><span class="typ">BigDecimal</span><span class="pln"> bd</span><span class="pun">=</span><span class="kwd">new</span><span class="pln"> </span><span class="typ">BigDecimal</span><span class="pun">\(</span><span class="lit">10</span><span class="pun">\);</span><span class="pln">
    bd </span><span class="pun">=</span><span class="pln"> bd</span><span class="pun">.</span><span class="pln">add</span><span class="pun">\(</span><span class="kwd">new</span><span class="pln"> </span><span class="typ">BigDecimal</span><span class="pun">\(</span><span class="lit">5</span><span class="pun">\)\);</span><span class="pln"> </span><span class="com">// this won't trigger the rule</span><span class="pln">
  </span><span class="pun">\}</span><span class="pln">
</span><span class="pun">\}</span><span class="pln">

      </span></pre></div>

u: (UnusedNullCheckInEquals) After checking an object reference for null, you should invoke equals\(\) on that object rather than passing it to another object's equals\(\) method.

<div class="source"><pre class="prettyprint"><span class="pln">
</span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Test</span><span class="pln"> </span><span class="pun">\{</span><span class="pln">

  </span><span class="kwd">public</span><span class="pln"> </span><span class="typ">String</span><span class="pln"> method1</span><span class="pun">\(\)</span><span class="pln"> </span><span class="pun">\{</span><span class="pln"> </span><span class="kwd">return</span><span class="pln"> </span><span class="str">"ok"</span><span class="pun">;\}</span><span class="pln">
  </span><span class="kwd">public</span><span class="pln"> </span><span class="typ">String</span><span class="pln"> method2</span><span class="pun">\(\)</span><span class="pln"> </span><span class="pun">\{</span><span class="pln"> </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;\}</span><span class="pln">

  </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> method</span><span class="pun">\(</span><span class="typ">String</span><span class="pln"> a</span><span class="pun">\)</span><span class="pln"> </span><span class="pun">\{</span><span class="pln">
    </span><span class="typ">String</span><span class="pln"> b</span><span class="pun">;</span><span class="pln">
	</span><span class="com">// I don't know it method1 \(\) can be "null"</span><span class="pln">
	</span><span class="com">// but I know "a" is not null..</span><span class="pln">
	</span><span class="com">// I'd better write a.equals \(method1 \(\)\)</span><span class="pln">

	</span><span class="kwd">if</span><span class="pln"> </span><span class="pun"> \(</span><span class="pln">a</span><span class="pun">!=</span><span class="kwd">null</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> method1</span><span class="pun">\(\).</span><span class="pln">equals</span><span class="pun">\(</span><span class="pln">a</span><span class="pun">\)\)</span><span class="pln"> </span><span class="pun">\{</span><span class="pln"> </span><span class="com">// will trigger the rule</span><span class="pln">
	</span><span class="com">//whatever</span><span class="pln">
	</span><span class="pun">\}</span><span class="pln">

	</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">\(</span><span class="pln">method1</span><span class="pun">\(\).</span><span class="pln">equals</span><span class="pun">\(</span><span class="pln">a</span><span class="pun">\)</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> a </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">\)</span><span class="pln"> </span><span class="pun">\{</span><span class="pln"> </span><span class="com">// won't trigger the rule</span><span class="pln">
	</span><span class="com">//whatever</span><span class="pln">
	</span><span class="pun">\}</span><span class="pln">

	</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">\(</span><span class="pln">a</span><span class="pun">!=</span><span class="kwd">null</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> method1</span><span class="pun">\(\).</span><span class="pln">equals</span><span class="pun">\(</span><span class="pln">b</span><span class="pun">\)\)</span><span class="pln"> </span><span class="pun">\{</span><span class="pln"> </span><span class="com">// won't trigger the rule</span><span class="pln">
	</span><span class="com">//whatever</span><span class="pln">
	</span><span class="pun">\}</span><span class="pln">

	</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">\(</span><span class="pln">a</span><span class="pun">!=</span><span class="kwd">null</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> </span><span class="str">"LITERAL"</span><span class="pun">.</span><span class="pln">equals</span><span class="pun">\(</span><span class="pln">a</span><span class="pun">\)\)</span><span class="pln"> </span><span class="pun">\{</span><span class="pln"> </span><span class="com">// won't trigger the rule</span><span class="pln">
	</span><span class="com">//whatever</span><span class="pln">
	</span><span class="pun">\}</span><span class="pln">

	</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">\(</span><span class="pln">a</span><span class="pun">!=</span><span class="kwd">null</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> </span><span class="pun">!</span><span class="pln">a</span><span class="pun">.</span><span class="pln">equals</span><span class="pun">\(</span><span class="str">"go"</span><span class="pun">\)\)</span><span class="pln"> </span><span class="pun">\{</span><span class="pln"> </span><span class="com">// won't trigger the rule</span><span class="pln">
	a</span><span class="pun">=</span><span class="pln">method2</span><span class="pun">\(\);</span><span class="pln">
	</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">\(</span><span class="pln">method1</span><span class="pun">\(\).</span><span class="pln">equals</span><span class="pun">\(</span><span class="pln">a</span><span class="pun">\)\)</span><span class="pln"> </span><span class="pun">\{</span><span class="pln">
	</span><span class="com">//whatever</span><span class="pln">
	</span><span class="pun">\}</span><span class="pln">
  </span><span class="pun">\}</span><span class="pln">
</span><span class="pun">\}</span><span class="pln">
</span><span class="pun">\}</span><span class="pln">

			</span></pre></div>

u: (unused null check in equals) After checking an object reference for null, you should invoke equals\(\) on that object rather than passing it to another object's equals\(\) method.

<div class="source"><pre class="prettyprint"><span class="pln">
</span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Test</span><span class="pln"> </span><span class="pun">\{</span><span class="pln">

  </span><span class="kwd">public</span><span class="pln"> </span><span class="typ">String</span><span class="pln"> method1</span><span class="pun">\(\)</span><span class="pln"> </span><span class="pun">\{</span><span class="pln"> </span><span class="kwd">return</span><span class="pln"> </span><span class="str">"ok"</span><span class="pun">;\}</span><span class="pln">
  </span><span class="kwd">public</span><span class="pln"> </span><span class="typ">String</span><span class="pln"> method2</span><span class="pun">\(\)</span><span class="pln"> </span><span class="pun">\{</span><span class="pln"> </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;\}</span><span class="pln">

  </span><span class="kwd">public</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> method</span><span class="pun">\(</span><span class="typ">String</span><span class="pln"> a</span><span class="pun">\)</span><span class="pln"> </span><span class="pun">\{</span><span class="pln">
    </span><span class="typ">String</span><span class="pln"> b</span><span class="pun">;</span><span class="pln">
	</span><span class="com">// I don't know it method1 \(\) can be "null"</span><span class="pln">
	</span><span class="com">// but I know "a" is not null..</span><span class="pln">
	</span><span class="com">// I'd better write a.equals \(method1 \(\)\)</span><span class="pln">

	</span><span class="kwd">if</span><span class="pln"> </span><span class="pun"> \(</span><span class="pln">a</span><span class="pun">!=</span><span class="kwd">null</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> method1</span><span class="pun">\(\).</span><span class="pln">equals</span><span class="pun">\(</span><span class="pln">a</span><span class="pun">\)\)</span><span class="pln"> </span><span class="pun">\{</span><span class="pln"> </span><span class="com">// will trigger the rule</span><span class="pln">
	</span><span class="com">//whatever</span><span class="pln">
	</span><span class="pun">\}</span><span class="pln">

	</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">\(</span><span class="pln">method1</span><span class="pun">\(\).</span><span class="pln">equals</span><span class="pun">\(</span><span class="pln">a</span><span class="pun">\)</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> a </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">\)</span><span class="pln"> </span><span class="pun">\{</span><span class="pln"> </span><span class="com">// won't trigger the rule</span><span class="pln">
	</span><span class="com">//whatever</span><span class="pln">
	</span><span class="pun">\}</span><span class="pln">

	</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">\(</span><span class="pln">a</span><span class="pun">!=</span><span class="kwd">null</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> method1</span><span class="pun">\(\).</span><span class="pln">equals</span><span class="pun">\(</span><span class="pln">b</span><span class="pun">\)\)</span><span class="pln"> </span><span class="pun">\{</span><span class="pln"> </span><span class="com">// won't trigger the rule</span><span class="pln">
	</span><span class="com">//whatever</span><span class="pln">
	</span><span class="pun">\}</span><span class="pln">

	</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">\(</span><span class="pln">a</span><span class="pun">!=</span><span class="kwd">null</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> </span><span class="str">"LITERAL"</span><span class="pun">.</span><span class="pln">equals</span><span class="pun">\(</span><span class="pln">a</span><span class="pun">\)\)</span><span class="pln"> </span><span class="pun">\{</span><span class="pln"> </span><span class="com">// won't trigger the rule</span><span class="pln">
	</span><span class="com">//whatever</span><span class="pln">
	</span><span class="pun">\}</span><span class="pln">

	</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">\(</span><span class="pln">a</span><span class="pun">!=</span><span class="kwd">null</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> </span><span class="pun">!</span><span class="pln">a</span><span class="pun">.</span><span class="pln">equals</span><span class="pun">\(</span><span class="str">"go"</span><span class="pun">\)\)</span><span class="pln"> </span><span class="pun">\{</span><span class="pln"> </span><span class="com">// won't trigger the rule</span><span class="pln">
	a</span><span class="pun">=</span><span class="pln">method2</span><span class="pun">\(\);</span><span class="pln">
	</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">\(</span><span class="pln">method1</span><span class="pun">\(\).</span><span class="pln">equals</span><span class="pun">\(</span><span class="pln">a</span><span class="pun">\)\)</span><span class="pln"> </span><span class="pun">\{</span><span class="pln">
	</span><span class="com">//whatever</span><span class="pln">
	</span><span class="pun">\}</span><span class="pln">
  </span><span class="pun">\}</span><span class="pln">
</span><span class="pun">\}</span><span class="pln">
</span><span class="pun">\}</span><span class="pln">

			</span></pre></div>

u: (UnusedPrivateField) Detects when a private field is declared and/or assigned a value, but not used.

<div class="source"><pre>

public class Something \{
  private static int FOO = 2; // Unused
  private int i = 5; // Unused
  private int j = 6;
  public int addOne \(\) \{
    return j++;
  \}
\}


            </pre></div>

u: (unused private field) Detects when a private field is declared and/or assigned a value, but not used.

<div class="source"><pre>

public class Something \{
  private static int FOO = 2; // Unused
  private int i = 5; // Unused
  private int j = 6;
  public int addOne \(\) \{
    return j++;
  \}
\}


            </pre></div>

u: (UnusedLocalVariable)  Detects when a local variable is declared and/or assigned, but not used.

<div class="source"><pre>

public class Foo \{
 public void doSomething \(\) \{
  int i = 5; // Unused
 \}
\}


            </pre></div>

u: (unused local variable)  Detects when a local variable is declared and/or assigned, but not used.

<div class="source"><pre>

public class Foo \{
 public void doSomething \(\) \{
  int i = 5; // Unused
 \}
\}


            </pre></div>

u: (UnusedPrivateMethod) Unused Private Method detects when a private method is declared but is unused.

<div class="source"><pre>

public class Something \{
 private void foo \(\) \{\} // unused
\}


            </pre></div>

u: (unused private method) Unused Private Method detects when a private method is declared but is unused.

<div class="source"><pre>

public class Something \{
 private void foo \(\) \{\} // unused
\}


            </pre></div>

u: (UnusedFormalParameter) Avoid passing parameters to methods or constructors and then not using those parameters.

<div class="source"><pre>

public class Foo \{
 private void bar \(String howdy \) \{
  // howdy is not used
 \}


            </pre></div>

u: (unused formal parameter) Avoid passing parameters to methods or constructors and then not using those parameters.

<div class="source"><pre>

public class Foo \{
 private void bar \(String howdy \) \{
  // howdy is not used
 \}


            </pre></div>

u: (ExcessiveMethodLength) Violations of this rule usually indicate that the method is doing too much. Try to reduce the method size by creating helper methods and removing any copy/pasted code.

<div class="source"><pre>

public class Foo \{
 public void doSomething \(\) \{
  System.out.println \("Hello world!"\);
  System.out.println \("Hello world!"\);
  // 98 copies omitted for brevity.
 \}
\}


            </pre></div>

u: (excessive method length) Violations of this rule usually indicate that the method is doing too much. Try to reduce the method size by creating helper methods and removing any copy/pasted code.

<div class="source"><pre>

public class Foo \{
 public void doSomething \(\) \{
  System.out.println \("Hello world!"\);
  System.out.println \("Hello world!"\);
  // 98 copies omitted for brevity.
 \}
\}


            </pre></div>

u: (ExcessiveParameterList) Long parameter lists can indicate that a new object should be created to wrap the numerous parameters. Basically, try to group the parameters together.

<div class="source"><pre>

public class Foo \{
 public void addData \(
  int p0, int p1, int p2, int p3, int p4, int p5,
  int p5, int p6, int p7, int p8, int p9, int p10 \) \{
  \}
 \}
\}


            </pre></div>

u: (excessive parameter list) Long parameter lists can indicate that a new object should be created to wrap the numerous parameters. Basically, try to group the parameters together.

<div class="source"><pre>

public class Foo \{
 public void addData \(
  int p0, int p1, int p2, int p3, int p4, int p5,
  int p5, int p6, int p7, int p8, int p9, int p10 \) \{
  \}
 \}
\}


            </pre></div>

u: (ExcessiveClassLength) Long Class files are indications that the class may be trying to do too much. Try to break it down, and reduce the size to something manageable.

<div class="source"><pre>

public class Foo \{
  public void bar \(\) \{
    // 1000 lines of code
  \}
\}


            </pre></div>

u: (excessive class length) Long Class files are indications that the class may be trying to do too much. Try to break it down, and reduce the size to something manageable.

<div class="source"><pre>

public class Foo \{
  public void bar \(\) \{
    // 1000 lines of code
  \}
\}


            </pre></div>

u: (TooManyFields) Classes that have too many fields could be redesigned to have fewer fields, possibly through some nested object grouping of some of the information. For example, a class with city/state/zip fields could instead have one Address field.

<div class="source"><pre>

public class Person \{
   String one;
   int two;
   int three;
   \[... many more public fields ... \]
\}


            </pre></div>

u: (too many fields) Classes that have too many fields could be redesigned to have fewer fields, possibly through some nested object grouping of some of the information. For example, a class with city/state/zip fields could instead have one Address field.

<div class="source"><pre>

public class Person \{
   String one;
   int two;
   int three;
   \[... many more public fields ... \]
\}


            </pre></div>

# Documentation Checkstyle

u: (JavadocMethod)  Checks the Javadoc of a method or constructor. By default, does not check for unused throws. To allow documented java.lang.RuntimeExceptions that are not declared, set property allowUndeclaredRTE to true. The scope to verify is specified using the Scope class and defaults to Scope.PRIVATE. To verify another scope, set property scope to a different scope.

Error messages about parameters and type parameters for which no param tags are present can be suppressed by defining property allowMissingParamTags. Error messages about exceptions which are declared to be thrown, but for which no throws tag is present can be suppressed by defining property allowMissingThrowsTags. Error messages about methods which return non-void but for which no return tag is present can be suppressed by defining property allowMissingReturnTag.

Javadoc is not required on a method that is tagged with the \@Override annotation. However under Java 5 it is not possible to mark a method required for an interface \(this was corrected under Java 6 \). Hence Checkstyle supports using the convention of using a single \{ \@inheritDoc \} tag instead of all the other tags.

Note that only inheritable items will allow the \{ \@inheritDoc \} tag to be used in place of comments. Static methods at all visibilities, private non-static methods and constructors are not inheritable.

For example, if the following method is implementing a method required by an interface, then the Javadoc could be done as:

/** \{ \@inheritDoc \} */
public int checkReturnTag \(final int aTagIndex,
                          JavadocTag\[\] aTags,
                          int aLineNo\)
The classpath may need to be configured to locate the class information. The classpath configuration is dependent on the mechanism used to invoke Checkstyle.

u: (javadoc method)  Checks the Javadoc of a method or constructor. By default, does not check for unused throws. To allow documented java.lang.RuntimeExceptions that are not declared, set property allowUndeclaredRTE to true. The scope to verify is specified using the Scope class and defaults to Scope.PRIVATE. To verify another scope, set property scope to a different scope.

Error messages about parameters and type parameters for which no param tags are present can be suppressed by defining property allowMissingParamTags. Error messages about exceptions which are declared to be thrown, but for which no throws tag is present can be suppressed by defining property allowMissingThrowsTags. Error messages about methods which return non-void but for which no return tag is present can be suppressed by defining property allowMissingReturnTag.

Javadoc is not required on a method that is tagged with the \@Override annotation. However under Java 5 it is not possible to mark a method required for an interface \(this was corrected under Java 6 \). Hence Checkstyle supports using the convention of using a single \{ \@inheritDoc \} tag instead of all the other tags.

Note that only inheritable items will allow the \{ \@inheritDoc \} tag to be used in place of comments. Static methods at all visibilities, private non-static methods and constructors are not inheritable.

For example, if the following method is implementing a method required by an interface, then the Javadoc could be done as:

/** \{ \@inheritDoc \} */
public int checkReturnTag \(final int aTagIndex,
                          JavadocTag\[\] aTags,
                          int aLineNo\)
The classpath may need to be configured to locate the class information. The classpath configuration is dependent on the mechanism used to invoke Checkstyle.

u: (JavadocType) Checks Javadoc comments for class and interface definitions. By default, does not check for author or version tags. The scope to verify is specified using the Scope class and defaults to Scope.PRIVATE. To verify another scope, set property scope to one of the Scope constants. To define the format for an author tag or a version tag, set property authorFormat or versionFormat respectively to a regular expression.

Does not perform checks for author and version tags for inner classes, as they should be redundant because of outer class.

Error messages about type parameters for which no param tags are present can be suppressed by defining property allowMissingParamTags.

u: (javadoc type) Checks Javadoc comments for class and interface definitions. By default, does not check for author or version tags. The scope to verify is specified using the Scope class and defaults to Scope.PRIVATE. To verify another scope, set property scope to one of the Scope constants. To define the format for an author tag or a version tag, set property authorFormat or versionFormat respectively to a regular expression.

Does not perform checks for author and version tags for inner classes, as they should be redundant because of outer class.

Error messages about type parameters for which no param tags are present can be suppressed by defining property allowMissingParamTags.

u: (JavadocVariable) Checks that variables have Javadoc comments. Ignores serialVersionUID fields.

u: (javadoc variable) Checks that variables have Javadoc comments. Ignores serialVersionUID fields.

# Documentation PMD
u: (UncommentedEmptyMethod) Uncommented Empty Method finds instances where a method does not contain statements, but there is no comment. By explicitly commenting empty methods it is easier to distinguish between intentional \(commented \) and unintentional empty methods.

<div class="source"><pre>
//MethodDeclaration/Block \[ count \(BlockStatement \) = 0 and \@containsComment = 'false' \]

             </pre></div>

u: (uncommented empty method) Uncommented Empty Method finds instances where a method does not contain statements, but there is no comment. By explicitly commenting empty methods it is easier to distinguish between intentional \(commented \) and unintentional empty methods.

<div class="source"><pre>
//MethodDeclaration/Block \[ count \(BlockStatement \) = 0 and \@containsComment = 'false' \]

             </pre></div>

u: (UncommentedEmptyConstructor) Uncommented Empty Constructor finds instances where a constructor does not contain statements, but there is no comment. By explicitly commenting empty constructors it is easier to distinguish between intentional \(commented \) and unintentional empty constructors.
<div class="source"><pre>

public Foo \(\) \{
  super \(\);
\}


            </pre></div>

u: (uncommented empty constructor) Uncommented Empty Constructor finds instances where a constructor does not contain statements, but there is no comment. By explicitly commenting empty constructors it is easier to distinguish between intentional \(commented \) and unintentional empty constructors.
<div class="source"><pre>

public Foo \(\) \{
  super \(\);
\}


            </pre></div>

# Testing PMD

u: (JUnitStaticSuite) The suite \(\) method in a JUnit test needs to be both public and static.

<div class="source"><pre>

import junit.framework.*;
public class Foo extends TestCase \{
 public void suite \(\) \{\} // oops, should be static
 private static void suite \(\) \{\} // oops, should be public
\}


            </pre></div>

u: (JUnit static suite) The suite \(\) method in a JUnit test needs to be both public and static.

<div class="source"><pre>

import junit.framework.*;
public class Foo extends TestCase \{
 public void suite \(\) \{\} // oops, should be static
 private static void suite \(\) \{\} // oops, should be public
\}


            </pre></div>

u: (JUnitSpelling) 	Some JUnit framework methods are easy to misspell.

<div class="source"><pre>

import junit.framework.*;
public class Foo extends TestCase \{
 public void setup \(\) \{\} // oops, should be setUp
 public void TearDown \(\) \{\} // oops, should be tearDown
\}


            </pre></div>

u: (JUnit spelling) 	Some JUnit framework methods are easy to misspell.

<div class="source"><pre>

import junit.framework.*;
public class Foo extends TestCase \{
 public void setup \(\) \{\} // oops, should be setUp
 public void TearDown \(\) \{\} // oops, should be tearDown
\}


            </pre></div>

u: (JUnitAssertionsShouldIncludeMessage) JUnit assertions should include a message - i.e., use the three argument version of assertEquals \(\), not the two argument version.

<div class="source"><pre>

public class Foo extends TestCase \{
 public void testSomething \(\) \{
  assertEquals \("foo", "bar"\);
  // Use the form:
  // assertEquals \("Foo does not equals bar", "foo", "bar"\);
  // instead
 \}
\}


            </pre></div>

u: (JUnit assertions should include message) JUnit assertions should include a message - i.e., use the three argument version of assertEquals \(\), not the two argument version.

<div class="source"><pre>

public class Foo extends TestCase \{
 public void testSomething \(\) \{
  assertEquals \("foo", "bar"\);
  // Use the form:
  // assertEquals \("Foo does not equals bar", "foo", "bar"\);
  // instead
 \}
\}


            </pre></div>

u: (JUnitTestClassNeedsTestCase) Test classes end with the suffix Test. Having a non-test class with that name is not a good practice, since most people will assume it is a test case. Test classes have test methods named testXXX.

<div class="source"><pre>

//Consider changing the name of the class if it is not a test
//Consider adding test methods if it is a test
public class CarTest \{
   public static void main \(String\[\] args\) \{
    // do something
   \}
   // code
\}


            </pre></div>

u: (JUnit test class needs test case) Test classes end with the suffix Test. Having a non-test class with that name is not a good practice, since most people will assume it is a test case. Test classes have test methods named testXXX.

<div class="source"><pre>

//Consider changing the name of the class if it is not a test
//Consider adding test methods if it is a test
public class CarTest \{
   public static void main \(String\[\] args\) \{
    // do something
   \}
   // code
\}


            </pre></div>

u: (UseAssertSameInsteadOfAssertTrue) This rule detects JUnit assertions in object references equality. These assertions should be made by more specific methods, like assertSame, assertNotSame.

<div class="source"><pre>

public class FooTest extends TestCase \{
 void testCode \(\) \{
  Object a, b;
  assertTrue \(a==b \); // bad usage
  assertSame \(a, b \);  // good usage
 \}
\}


            </pre></div>

u: (use assert same instead of assert true) This rule detects JUnit assertions in object references equality. These assertions should be made by more specific methods, like assertSame, assertNotSame.

<div class="source"><pre>

public class FooTest extends TestCase \{
 void testCode \(\) \{
  Object a, b;
  assertTrue \(a==b \); // bad usage
  assertSame \(a, b \);  // good usage
 \}
\}


            </pre></div>

u: (UseAssertNullInsteadOfAssertTrue) This rule detects JUnit assertions in object references equality. These assertions should be made by more specific methods, like assertNull, assertNotNull.

<div class="source"><pre>

 public class FooTest extends TestCase \{
  void testCode \(\) \{
   Object a = doSomething \(\);
   assertTrue \( a==null \); // bad usage
   assertNull \( a \);  // good usage
   assertTrue \( a != null \); // bad usage
   assertNotNull \(a \);  // good usage
  \}
 \}


            </pre></div>

u: (use assert null instead of assert true) This rule detects JUnit assertions in object references equality. These assertions should be made by more specific methods, like assertNull, assertNotNull.

<div class="source"><pre>

 public class FooTest extends TestCase \{
  void testCode \(\) \{
   Object a = doSomething \(\);
   assertTrue \( a==null \); // bad usage
   assertNull \( a \);  // good usage
   assertTrue \( a != null \); // bad usage
   assertNotNull \(a \);  // good usage
  \}
 \}


            </pre></div>

u: (SimplifyBooleanAssertion) Avoid negation in an assertTrue or assertFalse test. For example, rephrase: assertTrue \( !expr \); as: assertFalse \( expr \);

<div class="source"><pre>

public class SimpleTest extends TestCase \{
 public void testX \(\) \{
  assertTrue \("not empty", !r.isEmpty \(\)\); // replace with assertFalse \("not empty", r.isEmpty \(\)\)
  assertFalse \(!r.isEmpty \(\)\); // replace with assertTrue \(r.isEmpty \(\)\)
 \}
\}


            </pre></div>

u: (simplify boolean assertion) Avoid negation in an assertTrue or assertFalse test. For example, rephrase: assertTrue \( !expr \); as: assertFalse \( expr \);

<div class="source"><pre>

public class SimpleTest extends TestCase \{
 public void testX \(\) \{
  assertTrue \("not empty", !r.isEmpty \(\)\); // replace with assertFalse \("not empty", r.isEmpty \(\)\)
  assertFalse \(!r.isEmpty \(\)\); // replace with assertTrue \(r.isEmpty \(\)\)
 \}
\}


            </pre></div>
