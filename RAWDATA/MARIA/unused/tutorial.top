topic: ~introductions keep repeat []

t: [Hello] [Hi] [Hey] Mukund, I can help you with any questions related to Syntax errors!

u: WHAT (what are you) I am a virtual TA.

u: ( \{ expected) The reasons can be a. Usually this is just a missing semicolon, b. sometimes it can be caused by unbalanced parenthesis on the previous line

u: (already defined) Check if you are declaring variables with same name twice "<html>"

u: (array not initialized) Looks like you forgot to initialize an array with the new operator. e.g. new int \[ \]

u: (. expected) You must import either a packagename.* or packagename. Classname. You can’t just import packagename or import Classname. You don’t import classes in the same package as the current class. In other words, the thing you import will always contain at least one .. You don’t use import for code not in any package. You have to put such classes on the classpath. Whenever you have more than one class, it is a good idea to assign every class to an explicit package with a package statement. In summary, you import fully qualified classes, with package and classname separated by a dot. You don’t import classes without packages.

u: (.class expected) You might have written int i where you meant just plain i.

u: (; expected) 1. Usually this is just a missing semicolon 2. Sometimes it can be caused by unbalanced () on the previous line. 3. Sometimes it can be cause by junk on the previous line. This junk might be far to the right off the screen. 4. Sometimes it is caused by spelling the keyword if incorrectly nearby. 5. Sometimes it is a missing + concatenation operator. C programmers often make this one on multi-line Strings since the concatenation operator is implied in C.

u: (; missing) The line the error is showing is missing a semicolon

u: (= expected) You might want to look for a stray \{ just before where it is complaining

u: (attempt to reference) missing dummy pair of parentheses after the 0-argument method name.

u: (attempt to rename) Your jar is in use by some running Applet or application. Shut it down to build and sign the jar.

u: (bad class file) Check that the package statement and the class statement have names that are precisely correct including case and that this file is in a directory that precisely matches the package name and the source file name that precisely matches the class name followed by .java.

u: (blank final) Check that your final variable is indeed so initialised. If it is, remove the final, to bypass a bug in the Javac 1.1 compiler.

u: (Boolean dereferenced) You need extra layers of parentheses around your casting.

u: (Bound mismatch) You forget to implement Comparable on the class X you are sorting

u: (can’t access class) You forgot to make the class PUBLIC

u: (can’t be applied) You wrote x.setVisible\(\) instead of x.setVisible\(true\), or similar parameter mismatch. Check the types of parameters and arguments for an exact match. Whenever you see cannot be applied check the Javadoc to make sure the signature of the method you are calling matches the types of the arguments. The problem often is you are sure a method must logically have to exist that does not.

u: (can’t be dereferenced) You need extra layers of parentheses around your casting. or perhaps you may have written something like i.toString\(\) where i is an int rather than an object with methods. You need to write something like  Integer.toString\(i\) instead. ints can’t have any instance methods. They can be parameters to either static or instance methods though.

u: (can’t be instantiated) You are missing the default constructor for your Applet. See The Case of the Disappearing Constructors.

u: (can’t convert from Object to X) This error often comes up in the context of the clone method which, without covariance, returns an Object reference not the specific type of the Object cloned as you might naïvely expect. You tried to use a general Object reference in a context that requires something more specific. Sometimes all you need is a cast.

u: (cannot find symbol) You used a variable name you did not define. Perhaps you forgot the declaration. Perhaps you declared it inside a block/loop and you tried to use it outside the block/loop. You must move the declaration to an encompassing outer block that encloses all the references. Perhaps you spelled the variable slightly differently in declaration and reference. Watch your caps and double letters carefully. Perhaps you left out or mistyped the corresponding import or static import.

u: (can’t instantiate abstract class) missing method to fulfill an interface implementation

u: (can’t make static reference) using an instance variable in a static method

u: (cannot override) You can override a default or protected method with a public one, but not the reverse. Overridden methods cannot add any throws clauses not in the base method they are overriding.

u: (cannot resolve constructor) If a subclasses constructor does not call one of the constructors of the superclass as the very first thing, java inserts a call to the default constructor for you super\(\). If you have not defined that null constructor, you will get an error. The usual way to fix it is by inserting some sort of super\(parm\); as the first statement of your subclass constructor. See also hints on resolving symbols.

u: (cannot resolve symbol) I know

u: (CLOSEBRACEEXPECTED) 1. Missing \} at the end of a class <br/>
2. Missing \} is on a line containing // before the \} <br/>
3. Failure to enclose initializer code in the \{\} or static \{\} <br/>
4. Code has to live inside some method, or inside some initializer. It cant be left lying out in the middle of the class declarations <br/>
5. Forgetting static \{\} around class init code

u: (CANNOTFINDSYMBOL) You used a variable name you did not define. Perhaps you forgot the declaration. Perhaps you declared it inside a block/loop and you tried to sue it outside the block/loop. You mush move the declaration to an encompassing outer block that encloses all the references. Perhaps you spelled the variable slightly differently in declaration and reference. Watch your caps and double letters carefully. Perhaps you left out or mistyped the corresponsing import or static import.

u: (MISSINGRETURN) No Matter how control flows through your method, it must end with a return statement, unless the mo=ethod has a void return. The most common failing is when you catch an exception. The return in the try body conceptually might never be executed because of an exception potentially being triggered. You need a return in the catch block or after the catch block too. Javac is not as clever as you. You may be sure the exception will never dodge the return in the try block, but javac cant be sure. 
